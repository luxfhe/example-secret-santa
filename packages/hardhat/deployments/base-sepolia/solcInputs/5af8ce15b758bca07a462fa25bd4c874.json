{
  "language": "Solidity",
  "sources": {
    "@luxfheprotocol/cofhe-contracts/FHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n// solhint-disable one-contract-per-file\n\npragma solidity >=0.8.19 <0.9.0;\n\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {FunctionId, ITaskManager, Utils, EncryptedInput, InEbool, InEuint8, InEuint16, InEuint32, InEuint64, InEuint128, InEuint256, InEaddress} from \"./ICofhe.sol\";\n\ntype ebool is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\ntype euint64 is uint256;\ntype euint128 is uint256;\ntype euint256 is uint256;\ntype eaddress is uint256;\n\n// ================================\n// \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/\n// TODO : CHANGE ME AFTER DEPLOYING\n// /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\\n// ================================\n//solhint-disable const-name-snakecase\naddress constant TASK_MANAGER_ADDRESS = 0xeA30c4B8b44078Bbf8a6ef5b9f1eC1626C7848D9;\n\nlibrary Common {\n    error InvalidHexCharacter(bytes1 char);\n    error SecurityZoneOutOfBounds(int32 value);\n\n    // Default value for temp hash calculation in unary operations\n    string private constant DEFAULT_VALUE = \"0\";\n\n    function convertInt32ToUint256(int32 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SecurityZoneOutOfBounds(value);\n        }\n        return uint256(uint32(value));\n    }\n\n    function isInitialized(uint256 hash) internal pure returns (bool) {\n        return hash != 0;\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(ebool v) internal pure returns (bool) {\n        return isInitialized(ebool.unwrap(v));\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return isInitialized(euint8.unwrap(v));\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return isInitialized(euint16.unwrap(v));\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return isInitialized(euint32.unwrap(v));\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint64 v) internal pure returns (bool) {\n        return isInitialized(euint64.unwrap(v));\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint128 v) internal pure returns (bool) {\n        return isInitialized(euint128.unwrap(v));\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint256 v) internal pure returns (bool) {\n        return isInitialized(euint256.unwrap(v));\n    }\n\n    function isInitialized(eaddress v) internal pure returns (bool) {\n        return isInitialized(eaddress.unwrap(v));\n    }\n\n    function createUint256Inputs(uint256 input1) internal pure returns (uint256[] memory) {\n        uint256[] memory inputs = new uint256[](1);\n        inputs[0] = input1;\n        return inputs;\n    }\n\n    function createUint256Inputs(uint256 input1, uint256 input2) internal pure returns (uint256[] memory) {\n        uint256[] memory inputs = new uint256[](2);\n        inputs[0] = input1;\n        inputs[1] = input2;\n        return inputs;\n    }\n\n    function createUint256Inputs(uint256 input1, uint256 input2, uint256 input3) internal pure returns (uint256[] memory) {\n        uint256[] memory inputs = new uint256[](3);\n        inputs[0] = input1;\n        inputs[1] = input2;\n        inputs[2] = input3;\n        return inputs;\n    }\n}\n\nlibrary Impl {\n    function trivialEncrypt(uint256 value, uint8 toType, int32 securityZone) internal returns (uint256) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).createTask(toType, FunctionId.trivialEncrypt, new uint256[](0), Common.createUint256Inputs(value, toType, Common.convertInt32ToUint256(securityZone)));\n    }\n\n    function cast(uint256 key, uint8 toType) internal returns (uint256) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).createTask(toType, FunctionId.cast, Common.createUint256Inputs(key), Common.createUint256Inputs(toType));\n    }\n\n    function select(uint8 returnType, ebool control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).createTask(returnType,\n            FunctionId.select,\n            Common.createUint256Inputs(ebool.unwrap(control), ifTrue, ifFalse),\n            new uint256[](0));\n    }\n\n    function mathOp(uint8 returnType, uint256 lhs, uint256 rhs, FunctionId functionId) internal returns (uint256) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).createTask(returnType, functionId, Common.createUint256Inputs(lhs, rhs), new uint256[](0));\n    }\n\n    function decrypt(uint256 input) internal returns (uint256) {\n        ITaskManager(TASK_MANAGER_ADDRESS).createDecryptTask(input, msg.sender);\n        return input;\n    }\n\n    function getDecryptResult(uint256 input) internal view returns (uint256) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).getDecryptResult(input);\n    }\n\n    function getDecryptResultSafe(uint256 input) internal view returns (uint256 result, bool decrypted) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).getDecryptResultSafe(input);\n    }\n\n    function not(uint8 returnType, uint256 input) internal returns (uint256) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).createTask(returnType, FunctionId.not, Common.createUint256Inputs(input), new uint256[](0));\n    }\n\n    function square(uint8 returnType, uint256 input) internal returns (uint256) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).createTask(returnType, FunctionId.square, Common.createUint256Inputs(input), new uint256[](0));\n    }\n\n    function verifyInput(EncryptedInput memory input) internal returns (uint256) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).verifyInput(input, msg.sender);\n    }\n\n    /// @notice Generates a random value of a given type with the given seed, for the provided securityZone\n    /// @dev Calls the desired function\n    /// @param uintType the type of the random value to generate\n    /// @param seed the seed to use to create a random value from\n    /// @param securityZone the security zone to use for the random value\n    function random(uint8 uintType, uint64 seed, int32 securityZone) internal returns (uint256) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).createTask(uintType, FunctionId.random, new uint256[](0), Common.createUint256Inputs(seed, Common.convertInt32ToUint256(securityZone)));\n    }\n\n    /// @notice Generates a random value of a given type with the given seed\n    /// @dev Calls the desired function\n    /// @param uintType the type of the random value to generate\n    /// @param seed the seed to use to create a random value from\n    function random(uint8 uintType, uint32 seed) internal returns (uint256) {\n        return random(uintType, seed, 0);\n    }\n\n    /// @notice Generates a random value of a given type\n    /// @dev Calls the desired function\n    /// @param uintType the type of the random value to generate\n    function random(uint8 uintType) internal returns (uint256) {\n        return random(uintType, 0, 0);\n    }\n\n}\n\nlibrary FHE {\n\n    error InvalidEncryptedInput(uint8 got, uint8 expected);\n    /// @notice Perform the addition operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted addition\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the addition result\n    function add(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.add));\n    }\n\n    /// @notice Perform the addition operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted addition\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the addition result\n    function add(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.add));\n    }\n\n    /// @notice Perform the addition operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted addition\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the addition result\n    function add(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.add));\n    }\n\n    /// @notice Perform the addition operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted addition\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the addition result\n    function add(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.add));\n    }\n\n    /// @notice Perform the addition operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted addition\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the addition result\n    function add(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.add));\n    }\n\n    /// @notice Perform the addition operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted addition\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the addition result\n    function add(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.add));\n    }\n\n    /// @notice Perform the less than or equal to operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type ebool containing the comparison result\n    function lte(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.lte));\n    }\n\n    /// @notice Perform the less than or equal to operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type ebool containing the comparison result\n    function lte(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.lte));\n    }\n\n    /// @notice Perform the less than or equal to operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type ebool containing the comparison result\n    function lte(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.lte));\n    }\n\n    /// @notice Perform the less than or equal to operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type ebool containing the comparison result\n    function lte(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.lte));\n    }\n\n    /// @notice Perform the less than or equal to operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type ebool containing the comparison result\n    function lte(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.lte));\n    }\n\n    /// @notice Perform the less than or equal to operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type ebool containing the comparison result\n    function lte(euint256 lhs, euint256 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.lte));\n    }\n\n    /// @notice Perform the subtraction operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted subtraction\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the subtraction result\n    function sub(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.sub));\n    }\n\n    /// @notice Perform the subtraction operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted subtraction\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the subtraction result\n    function sub(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.sub));\n    }\n\n    /// @notice Perform the subtraction operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted subtraction\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the subtraction result\n    function sub(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.sub));\n    }\n\n    /// @notice Perform the subtraction operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted subtraction\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the subtraction result\n    function sub(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.sub));\n    }\n\n    /// @notice Perform the subtraction operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted subtraction\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the subtraction result\n    function sub(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.sub));\n    }\n\n    /// @notice Perform the subtraction operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted subtraction\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the subtraction result\n    function sub(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.sub));\n    }\n\n    /// @notice Perform the multiplication operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted multiplication\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the multiplication result\n    function mul(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.mul));\n    }\n\n    /// @notice Perform the multiplication operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted multiplication\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the multiplication result\n    function mul(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.mul));\n    }\n\n    /// @notice Perform the multiplication operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted multiplication\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the multiplication result\n    function mul(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.mul));\n    }\n\n    /// @notice Perform the multiplication operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted multiplication\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the multiplication result\n    function mul(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.mul));\n    }\n\n    /// @notice Perform the multiplication operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted multiplication\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the multiplication result\n    function mul(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.mul));\n    }\n\n    /// @notice Perform the multiplication operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted multiplication\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the multiplication result\n    function mul(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.mul));\n    }\n\n    /// @notice Perform the less than operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type ebool containing the comparison result\n    function lt(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.lt));\n    }\n\n    /// @notice Perform the less than operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type ebool containing the comparison result\n    function lt(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.lt));\n    }\n\n    /// @notice Perform the less than operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type ebool containing the comparison result\n    function lt(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.lt));\n    }\n\n    /// @notice Perform the less than operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type ebool containing the comparison result\n    function lt(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.lt));\n    }\n\n    /// @notice Perform the less than operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type ebool containing the comparison result\n    function lt(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.lt));\n    }\n\n    /// @notice Perform the less than operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type ebool containing the comparison result\n    function lt(euint256 lhs, euint256 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.lt));\n    }\n\n    /// @notice Perform the division operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted division\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the division result\n    function div(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.div));\n    }\n\n    /// @notice Perform the division operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted division\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the division result\n    function div(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.div));\n    }\n\n    /// @notice Perform the division operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted division\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the division result\n    function div(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.div));\n    }\n\n    /// @notice Perform the division operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted division\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the division result\n    function div(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.div));\n    }\n\n    /// @notice Perform the division operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted division\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the division result\n    function div(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.div));\n    }\n\n    /// @notice Perform the division operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted division\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the division result\n    function div(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.div));\n    }\n\n    /// @notice Perform the greater than operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type ebool containing the comparison result\n    function gt(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.gt));\n    }\n\n    /// @notice Perform the greater than operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type ebool containing the comparison result\n    function gt(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.gt));\n    }\n\n    /// @notice Perform the greater than operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type ebool containing the comparison result\n    function gt(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.gt));\n    }\n\n    /// @notice Perform the greater than operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type ebool containing the comparison result\n    function gt(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.gt));\n    }\n\n    /// @notice Perform the greater than operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type ebool containing the comparison result\n    function gt(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.gt));\n    }\n\n    /// @notice Perform the greater than operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type ebool containing the comparison result\n    function gt(euint256 lhs, euint256 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.gt));\n    }\n\n    /// @notice Perform the greater than or equal to operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type ebool containing the comparison result\n    function gte(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.gte));\n    }\n\n    /// @notice Perform the greater than or equal to operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type ebool containing the comparison result\n    function gte(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.gte));\n    }\n\n    /// @notice Perform the greater than or equal to operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type ebool containing the comparison result\n    function gte(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.gte));\n    }\n\n    /// @notice Perform the greater than or equal to operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type ebool containing the comparison result\n    function gte(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.gte));\n    }\n\n    /// @notice Perform the greater than or equal to operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type ebool containing the comparison result\n    function gte(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.gte));\n    }\n\n    /// @notice Perform the greater than or equal to operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted comparison\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type ebool containing the comparison result\n    function gte(euint256 lhs, euint256 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.gte));\n    }\n\n    /// @notice Perform the remainder operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted remainder calculation\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the remainder result\n    function rem(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.rem));\n    }\n\n    /// @notice Perform the remainder operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted remainder calculation\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the remainder result\n    function rem(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.rem));\n    }\n\n    /// @notice Perform the remainder operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted remainder calculation\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the remainder result\n    function rem(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.rem));\n    }\n\n    /// @notice Perform the remainder operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted remainder calculation\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the remainder result\n    function rem(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.rem));\n    }\n\n    /// @notice Perform the remainder operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted remainder calculation\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the remainder result\n    function rem(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.rem));\n    }\n\n    /// @notice Perform the remainder operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted remainder calculation\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the remainder result\n    function rem(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.rem));\n    }\n\n    /// @notice Perform the bitwise AND operation on two parameters of type ebool\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise AND\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return result of type ebool containing the AND result\n    function and(ebool lhs, ebool rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEbool(true);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEbool(true);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EBOOL_TFHE, ebool.unwrap(lhs), ebool.unwrap(rhs), FunctionId.and));\n    }\n\n    /// @notice Perform the bitwise AND operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise AND\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the AND result\n    function and(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.and));\n    }\n\n    /// @notice Perform the bitwise AND operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise AND\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the AND result\n    function and(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.and));\n    }\n\n    /// @notice Perform the bitwise AND operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise AND\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the AND result\n    function and(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.and));\n    }\n\n    /// @notice Perform the bitwise AND operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise AND\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the AND result\n    function and(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.and));\n    }\n\n    /// @notice Perform the bitwise AND operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise AND\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the AND result\n    function and(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.and));\n    }\n\n    /// @notice Perform the bitwise AND operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise AND\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the AND result\n    function and(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.and));\n    }\n\n    /// @notice Perform the bitwise OR operation on two parameters of type ebool\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise OR\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return result of type ebool containing the OR result\n    function or(ebool lhs, ebool rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEbool(true);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEbool(true);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EBOOL_TFHE, ebool.unwrap(lhs), ebool.unwrap(rhs), FunctionId.or));\n    }\n\n    /// @notice Perform the bitwise OR operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise OR\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the OR result\n    function or(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.or));\n    }\n\n    /// @notice Perform the bitwise OR operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise OR\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the OR result\n    function or(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.or));\n    }\n\n    /// @notice Perform the bitwise OR operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise OR\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the OR result\n    function or(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.or));\n    }\n\n    /// @notice Perform the bitwise OR operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise OR\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the OR result\n    function or(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.or));\n    }\n\n    /// @notice Perform the bitwise OR operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise OR\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the OR result\n    function or(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.or));\n    }\n\n    /// @notice Perform the bitwise OR operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise OR\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the OR result\n    function or(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.or));\n    }\n\n    /// @notice Perform the bitwise XOR operation on two parameters of type ebool\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise XOR\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return result of type ebool containing the XOR result\n    function xor(ebool lhs, ebool rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEbool(true);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEbool(true);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EBOOL_TFHE, ebool.unwrap(lhs), ebool.unwrap(rhs), FunctionId.xor));\n    }\n\n    /// @notice Perform the bitwise XOR operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise XOR\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the XOR result\n    function xor(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.xor));\n    }\n\n    /// @notice Perform the bitwise XOR operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise XOR\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the XOR result\n    function xor(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.xor));\n    }\n\n    /// @notice Perform the bitwise XOR operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise XOR\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the XOR result\n    function xor(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.xor));\n    }\n\n    /// @notice Perform the bitwise XOR operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise XOR\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the XOR result\n    function xor(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.xor));\n    }\n\n    /// @notice Perform the bitwise XOR operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise XOR\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the XOR result\n    function xor(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.xor));\n    }\n\n    /// @notice Perform the bitwise XOR operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted bitwise XOR\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the XOR result\n    function xor(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.xor));\n    }\n\n    /// @notice Perform the equality operation on two parameters of type ebool\n    /// @dev Verifies that inputs are initialized, performs encrypted equality check\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return result of type ebool containing the equality result\n    function eq(ebool lhs, ebool rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEbool(true);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEbool(true);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EBOOL_TFHE, ebool.unwrap(lhs), ebool.unwrap(rhs), FunctionId.eq));\n    }\n\n    /// @notice Perform the equality operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted equality check\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type ebool containing the equality result\n    function eq(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.eq));\n    }\n\n    /// @notice Perform the equality operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted equality check\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type ebool containing the equality result\n    function eq(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.eq));\n    }\n\n    /// @notice Perform the equality operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted equality check\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type ebool containing the equality result\n    function eq(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.eq));\n    }\n\n    /// @notice Perform the equality operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted equality check\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type ebool containing the equality result\n    function eq(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.eq));\n    }\n\n    /// @notice Perform the equality operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted equality check\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type ebool containing the equality result\n    function eq(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.eq));\n    }\n\n    /// @notice Perform the equality operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted equality check\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type ebool containing the equality result\n    function eq(euint256 lhs, euint256 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.eq));\n    }\n\n    /// @notice Perform the equality operation on two parameters of type eaddress\n    /// @dev Verifies that inputs are initialized, performs encrypted equality check\n    /// @param lhs input of type eaddress\n    /// @param rhs second input of type eaddress\n    /// @return result of type ebool containing the equality result\n    function eq(eaddress lhs, eaddress rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEaddress(address(0));\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEaddress(address(0));\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EADDRESS_TFHE, eaddress.unwrap(lhs), eaddress.unwrap(rhs), FunctionId.eq));\n    }\n\n    /// @notice Perform the inequality operation on two parameters of type ebool\n    /// @dev Verifies that inputs are initialized, performs encrypted inequality check\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return result of type ebool containing the inequality result\n    function ne(ebool lhs, ebool rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEbool(true);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEbool(true);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EBOOL_TFHE, ebool.unwrap(lhs), ebool.unwrap(rhs), FunctionId.ne));\n    }\n\n    /// @notice Perform the inequality operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted inequality check\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type ebool containing the inequality result\n    function ne(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.ne));\n    }\n\n    /// @notice Perform the inequality operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted inequality check\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type ebool containing the inequality result\n    function ne(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.ne));\n    }\n\n    /// @notice Perform the inequality operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted inequality check\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type ebool containing the inequality result\n    function ne(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.ne));\n    }\n\n    /// @notice Perform the inequality operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted inequality check\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type ebool containing the inequality result\n    function ne(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.ne));\n    }\n\n    /// @notice Perform the inequality operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted inequality check\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type ebool containing the inequality result\n    function ne(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.ne));\n    }\n\n    /// @notice Perform the inequality operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted inequality check\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type ebool containing the inequality result\n    function ne(euint256 lhs, euint256 rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.ne));\n    }\n\n    /// @notice Perform the inequality operation on two parameters of type eaddress\n    /// @dev Verifies that inputs are initialized, performs encrypted inequality check\n    /// @param lhs input of type eaddress\n    /// @param rhs second input of type eaddress\n    /// @return result of type ebool containing the inequality result\n    function ne(eaddress lhs, eaddress rhs) internal returns (ebool) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEaddress(address(0));\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEaddress(address(0));\n        }\n\n        return ebool.wrap(Impl.mathOp(Utils.EADDRESS_TFHE, eaddress.unwrap(lhs), eaddress.unwrap(rhs), FunctionId.ne));\n    }\n\n    /// @notice Perform the minimum operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted minimum comparison\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the minimum value\n    function min(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.min));\n    }\n\n    /// @notice Perform the minimum operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted minimum comparison\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the minimum value\n    function min(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.min));\n    }\n\n    /// @notice Perform the minimum operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted minimum comparison\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the minimum value\n    function min(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.min));\n    }\n\n    /// @notice Perform the minimum operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted minimum comparison\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the minimum value\n    function min(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.min));\n    }\n\n    /// @notice Perform the minimum operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted minimum comparison\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the minimum value\n    function min(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.min));\n    }\n\n    /// @notice Perform the minimum operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted minimum comparison\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the minimum value\n    function min(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.min));\n    }\n\n    /// @notice Perform the maximum operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted maximum calculation\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the maximum result\n    function max(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.max));\n    }\n\n    /// @notice Perform the maximum operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted maximum calculation\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the maximum result\n    function max(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.max));\n    }\n\n    /// @notice Perform the maximum operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted maximum calculation\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the maximum result\n    function max(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.max));\n    }\n\n    /// @notice Perform the maximum operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted maximum comparison\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the maximum value\n    function max(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.max));\n    }\n\n    /// @notice Perform the maximum operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted maximum comparison\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the maximum value\n    function max(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.max));\n    }\n\n    /// @notice Perform the maximum operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted maximum comparison\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the maximum value\n    function max(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.max));\n    }\n\n    /// @notice Perform the shift left operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted left shift\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the left shift result\n    function shl(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.shl));\n    }\n\n    /// @notice Perform the shift left operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted left shift\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the left shift result\n    function shl(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.shl));\n    }\n\n    /// @notice Perform the shift left operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted left shift\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the left shift result\n    function shl(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.shl));\n    }\n\n    /// @notice Perform the shift left operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted left shift\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the left shift result\n    function shl(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.shl));\n    }\n\n    /// @notice Perform the shift left operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted left shift\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the left shift result\n    function shl(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.shl));\n    }\n\n    /// @notice Perform the shift left operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted left shift\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the left shift result\n    function shl(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.shl));\n    }\n\n    /// @notice Perform the shift right operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted right shift\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the right shift result\n    function shr(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.shr));\n    }\n\n    /// @notice Perform the shift right operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted right shift\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the right shift result\n    function shr(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.shr));\n    }\n\n    /// @notice Perform the shift right operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted right shift\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the right shift result\n    function shr(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.shr));\n    }\n\n    /// @notice Perform the shift right operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted right shift\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the right shift result\n    function shr(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.shr));\n    }\n\n    /// @notice Perform the shift right operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted right shift\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the right shift result\n    function shr(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.shr));\n    }\n\n    /// @notice Perform the shift right operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted right shift\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the right shift result\n    function shr(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.shr));\n    }\n\n    /// @notice Perform the rol operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted left rotation\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the left rotation result\n    function rol(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.rol));\n    }\n\n    /// @notice Perform the rotate left operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted left rotation\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the left rotation result\n    function rol(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.rol));\n    }\n\n    /// @notice Perform the rotate left operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted left rotation\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the left rotation result\n    function rol(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.rol));\n    }\n\n    /// @notice Perform the rotate left operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted left rotation\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the left rotation result\n    function rol(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.rol));\n    }\n\n    /// @notice Perform the rotate left operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted left rotation\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the left rotation result\n    function rol(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.rol));\n    }\n\n    /// @notice Perform the rotate left operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted left rotation\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the left rotation result\n    function rol(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.rol));\n    }\n\n    /// @notice Perform the rotate right operation on two parameters of type euint8\n    /// @dev Verifies that inputs are initialized, performs encrypted right rotation\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return result of type euint8 containing the right rotation result\n    function ror(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.mathOp(Utils.EUINT8_TFHE, euint8.unwrap(lhs), euint8.unwrap(rhs), FunctionId.ror));\n    }\n\n    /// @notice Perform the rotate right operation on two parameters of type euint16\n    /// @dev Verifies that inputs are initialized, performs encrypted right rotation\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return result of type euint16 containing the right rotation result\n    function ror(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.mathOp(Utils.EUINT16_TFHE, euint16.unwrap(lhs), euint16.unwrap(rhs), FunctionId.ror));\n    }\n\n    /// @notice Perform the rotate right operation on two parameters of type euint32\n    /// @dev Verifies that inputs are initialized, performs encrypted right rotation\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return result of type euint32 containing the right rotation result\n    function ror(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.mathOp(Utils.EUINT32_TFHE, euint32.unwrap(lhs), euint32.unwrap(rhs), FunctionId.ror));\n    }\n\n    /// @notice Perform the rotate right operation on two parameters of type euint64\n    /// @dev Verifies that inputs are initialized, performs encrypted right rotation\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return result of type euint64 containing the right rotation result\n    function ror(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint64(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.mathOp(Utils.EUINT64_TFHE, euint64.unwrap(lhs), euint64.unwrap(rhs), FunctionId.ror));\n    }\n\n    /// @notice Perform the rotate right operation on two parameters of type euint128\n    /// @dev Verifies that inputs are initialized, performs encrypted right rotation\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return result of type euint128 containing the right rotation result\n    function ror(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint128(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.mathOp(Utils.EUINT128_TFHE, euint128.unwrap(lhs), euint128.unwrap(rhs), FunctionId.ror));\n    }\n\n    /// @notice Perform the rotate right operation on two parameters of type euint256\n    /// @dev Verifies that inputs are initialized, performs encrypted right rotation\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return result of type euint256 containing the right rotation result\n    function ror(euint256 lhs, euint256 rhs) internal returns (euint256) {\n        if (!Common.isInitialized(lhs)) {\n            lhs = asEuint256(0);\n        }\n        if (!Common.isInitialized(rhs)) {\n            rhs = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.mathOp(Utils.EUINT256_TFHE, euint256.unwrap(lhs), euint256.unwrap(rhs), FunctionId.ror));\n    }\n\n    /// @notice Performs the async decrypt operation on a ciphertext\n    /// @dev The decrypted output should be asynchronously handled by the IAsyncFHEReceiver implementation\n    /// @param input1 the input ciphertext\n    function decrypt(ebool input1) internal {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n\n        ebool.wrap(Impl.decrypt(ebool.unwrap(input1)));\n    }\n    /// @notice Performs the async decrypt operation on a ciphertext\n    /// @dev The decrypted output should be asynchronously handled by the IAsyncFHEReceiver implementation\n    /// @param input1 the input ciphertext\n    function decrypt(euint8 input1) internal {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n\n        euint8.wrap(Impl.decrypt(euint8.unwrap(input1)));\n    }\n    /// @notice Performs the async decrypt operation on a ciphertext\n    /// @dev The decrypted output should be asynchronously handled by the IAsyncFHEReceiver implementation\n    /// @param input1 the input ciphertext\n    function decrypt(euint16 input1) internal {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n\n        euint16.wrap(Impl.decrypt(euint16.unwrap(input1)));\n    }\n    /// @notice Performs the async decrypt operation on a ciphertext\n    /// @dev The decrypted output should be asynchronously handled by the IAsyncFHEReceiver implementation\n    /// @param input1 the input ciphertext\n    function decrypt(euint32 input1) internal {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n\n        euint32.wrap(Impl.decrypt(euint32.unwrap(input1)));\n    }\n    /// @notice Performs the async decrypt operation on a ciphertext\n    /// @dev The decrypted output should be asynchronously handled by the IAsyncFHEReceiver implementation\n    /// @param input1 the input ciphertext\n    function decrypt(euint64 input1) internal {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint64(0);\n        }\n\n        euint64.wrap(Impl.decrypt(euint64.unwrap(input1)));\n    }\n    /// @notice Performs the async decrypt operation on a ciphertext\n    /// @dev The decrypted output should be asynchronously handled by the IAsyncFHEReceiver implementation\n    /// @param input1 the input ciphertext\n    function decrypt(euint128 input1) internal {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint128(0);\n        }\n\n        euint128.wrap(Impl.decrypt(euint128.unwrap(input1)));\n    }\n    /// @notice Performs the async decrypt operation on a ciphertext\n    /// @dev The decrypted output should be asynchronously handled by the IAsyncFHEReceiver implementation\n    /// @param input1 the input ciphertext\n    function decrypt(euint256 input1) internal {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint256(0);\n        }\n\n        euint256.wrap(Impl.decrypt(euint256.unwrap(input1)));\n    }\n    /// @notice Performs the async decrypt operation on a ciphertext\n    /// @dev The decrypted output should be asynchronously handled by the IAsyncFHEReceiver implementation\n    /// @param input1 the input ciphertext\n    function decrypt(eaddress input1) internal {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEaddress(address(0));\n        }\n\n        Impl.decrypt(eaddress.unwrap(input1));\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted ebool ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The ebool ciphertext to get the decrypted value from\n    /// @return The decrypted boolean value\n    function getDecryptResult(ebool input1) internal view returns (bool) {\n        uint256 result = Impl.getDecryptResult(ebool.unwrap(input1));\n        return result != 0;\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted euint8 ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The euint8 ciphertext to get the decrypted value from\n    /// @return The decrypted uint8 value\n    function getDecryptResult(euint8 input1) internal view returns (uint8) {\n        return uint8(Impl.getDecryptResult(euint8.unwrap(input1)));\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted euint16 ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The euint16 ciphertext to get the decrypted value from\n    /// @return The decrypted uint16 value\n    function getDecryptResult(euint16 input1) internal view returns (uint16) {\n        return uint16(Impl.getDecryptResult(euint16.unwrap(input1)));\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted euint32 ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The euint32 ciphertext to get the decrypted value from\n    /// @return The decrypted uint32 value\n    function getDecryptResult(euint32 input1) internal view returns (uint32) {\n        return uint32(Impl.getDecryptResult(euint32.unwrap(input1)));\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted euint64 ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The euint64 ciphertext to get the decrypted value from\n    /// @return The decrypted uint64 value\n    function getDecryptResult(euint64 input1) internal view returns (uint64) {\n        return uint64(Impl.getDecryptResult(euint64.unwrap(input1)));\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted euint128 ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The euint128 ciphertext to get the decrypted value from\n    /// @return The decrypted uint128 value\n    function getDecryptResult(euint128 input1) internal view returns (uint128) {\n        return uint128(Impl.getDecryptResult(euint128.unwrap(input1)));\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted euint256 ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The euint256 ciphertext to get the decrypted value from\n    /// @return The decrypted uint256 value\n    function getDecryptResult(euint256 input1) internal view returns (uint256) {\n        return uint256(Impl.getDecryptResult(euint256.unwrap(input1)));\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted eaddress ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The eaddress ciphertext to get the decrypted value from\n    /// @return The decrypted address value\n    function getDecryptResult(eaddress input1) internal view returns (address) {\n        return address(uint160(Impl.getDecryptResult(eaddress.unwrap(input1))));\n    }\n\n    /// @notice Gets the decrypted value from a previously decrypted raw ciphertext\n    /// @dev This function will revert if the ciphertext is not yet decrypted. Use getDecryptResultSafe for a non-reverting version.\n    /// @param input1 The raw ciphertext to get the decrypted value from\n    /// @return The decrypted uint256 value\n    function getDecryptResult(uint256 input1) internal view returns (uint256) {\n        return Impl.getDecryptResult(input1);\n    }\n\n    /// @notice Safely gets the decrypted value from an ebool ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The ebool ciphertext to get the decrypted value from\n    /// @return result The decrypted boolean value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(ebool input1) internal view returns (bool result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(ebool.unwrap(input1));\n        return (_result != 0, _decrypted);\n    }\n\n    /// @notice Safely gets the decrypted value from a euint8 ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The euint8 ciphertext to get the decrypted value from\n    /// @return result The decrypted uint8 value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(euint8 input1) internal view returns (uint8 result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(euint8.unwrap(input1));\n        return (uint8(_result), _decrypted);\n    }\n\n    /// @notice Safely gets the decrypted value from a euint16 ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The euint16 ciphertext to get the decrypted value from\n    /// @return result The decrypted uint16 value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(euint16 input1) internal view returns (uint16 result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(euint16.unwrap(input1));\n        return (uint16(_result), _decrypted);\n    }\n\n    /// @notice Safely gets the decrypted value from a euint32 ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The euint32 ciphertext to get the decrypted value from\n    /// @return result The decrypted uint32 value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(euint32 input1) internal view returns (uint32 result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(euint32.unwrap(input1));\n        return (uint32(_result), _decrypted);\n    }\n\n    /// @notice Safely gets the decrypted value from a euint64 ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The euint64 ciphertext to get the decrypted value from\n    /// @return result The decrypted uint64 value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(euint64 input1) internal view returns (uint64 result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(euint64.unwrap(input1));\n        return (uint64(_result), _decrypted);\n    }\n\n    /// @notice Safely gets the decrypted value from a euint128 ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The euint128 ciphertext to get the decrypted value from\n    /// @return result The decrypted uint128 value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(euint128 input1) internal view returns (uint128 result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(euint128.unwrap(input1));\n        return (uint128(_result), _decrypted);\n    }\n\n    /// @notice Safely gets the decrypted value from a euint256 ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The euint256 ciphertext to get the decrypted value from\n    /// @return result The decrypted uint256 value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(euint256 input1) internal view returns (uint256 result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(euint256.unwrap(input1));\n        return (uint256(_result), _decrypted);\n    }\n\n    /// @notice Safely gets the decrypted value from an eaddress ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The eaddress ciphertext to get the decrypted value from\n    /// @return result The decrypted address value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(eaddress input1) internal view returns (address result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(eaddress.unwrap(input1));\n        return (address(uint160(_result)), _decrypted);\n    }\n\n    /// @notice Safely gets the decrypted value from a raw ciphertext\n    /// @dev Returns the decrypted value and a flag indicating whether the decryption has finished\n    /// @param input1 The raw ciphertext to get the decrypted value from\n    /// @return result The decrypted uint256 value\n    /// @return decrypted Flag indicating if the value was successfully decrypted\n    function getDecryptResultSafe(uint256 input1) internal view returns (uint256 result, bool decrypted) {\n        (uint256 _result, bool _decrypted) = Impl.getDecryptResultSafe(input1);\n        return (_result, _decrypted);\n    }\n\n    /// @notice Performs a multiplexer operation between two ebool values based on a selector\n    /// @dev If input1 is true, returns input2, otherwise returns input3. All inputs are initialized to defaults if not set.\n    /// @param input1 The selector of type ebool\n    /// @param input2 First choice of type ebool\n    /// @param input3 Second choice of type ebool\n    /// @return result of type ebool containing the selected value\n    function select(ebool input1, ebool input2, ebool input3) internal returns (ebool) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n        if (!Common.isInitialized(input2)) {\n            input2 = asEbool(false);\n        }\n        if (!Common.isInitialized(input3)) {\n            input3 = asEbool(false);\n        }\n\n        return ebool.wrap(Impl.select(Utils.EBOOL_TFHE, input1, ebool.unwrap(input2), ebool.unwrap(input3)));\n    }\n\n    /// @notice Performs a multiplexer operation between two euint8 values based on a selector\n    /// @dev If input1 is true, returns input2, otherwise returns input3. All inputs are initialized to defaults if not set.\n    /// @param input1 The selector of type ebool\n    /// @param input2 First choice of type euint8\n    /// @param input3 Second choice of type euint8\n    /// @return result of type euint8 containing the selected value\n    function select(ebool input1, euint8 input2, euint8 input3) internal returns (euint8) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n        if (!Common.isInitialized(input2)) {\n            input2 = asEuint8(0);\n        }\n        if (!Common.isInitialized(input3)) {\n            input3 = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.select(Utils.EUINT8_TFHE, input1, euint8.unwrap(input2), euint8.unwrap(input3)));\n    }\n\n    /// @notice Performs a multiplexer operation between two euint16 values based on a selector\n    /// @dev If input1 is true, returns input2, otherwise returns input3. All inputs are initialized to defaults if not set.\n    /// @param input1 The selector of type ebool\n    /// @param input2 First choice of type euint16\n    /// @param input3 Second choice of type euint16\n    /// @return result of type euint16 containing the selected value\n    function select(ebool input1, euint16 input2, euint16 input3) internal returns (euint16) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n        if (!Common.isInitialized(input2)) {\n            input2 = asEuint16(0);\n        }\n        if (!Common.isInitialized(input3)) {\n            input3 = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.select(Utils.EUINT16_TFHE, input1, euint16.unwrap(input2), euint16.unwrap(input3)));\n    }\n\n    /// @notice Performs a multiplexer operation between two euint32 values based on a selector\n    /// @dev If input1 is true, returns input2, otherwise returns input3. All inputs are initialized to defaults if not set.\n    /// @param input1 The selector of type ebool\n    /// @param input2 First choice of type euint32\n    /// @param input3 Second choice of type euint32\n    /// @return result of type euint32 containing the selected value\n    function select(ebool input1, euint32 input2, euint32 input3) internal returns (euint32) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n        if (!Common.isInitialized(input2)) {\n            input2 = asEuint32(0);\n        }\n        if (!Common.isInitialized(input3)) {\n            input3 = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.select(Utils.EUINT32_TFHE, input1, euint32.unwrap(input2), euint32.unwrap(input3)));\n    }\n\n    /// @notice Performs a multiplexer operation between two euint64 values based on a selector\n    /// @dev If input1 is true, returns input2, otherwise returns input3. All inputs are initialized to defaults if not set.\n    /// @param input1 The selector of type ebool\n    /// @param input2 First choice of type euint64\n    /// @param input3 Second choice of type euint64\n    /// @return result of type euint64 containing the selected value\n    function select(ebool input1, euint64 input2, euint64 input3) internal returns (euint64) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n        if (!Common.isInitialized(input2)) {\n            input2 = asEuint64(0);\n        }\n        if (!Common.isInitialized(input3)) {\n            input3 = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.select(Utils.EUINT64_TFHE, input1, euint64.unwrap(input2), euint64.unwrap(input3)));\n    }\n\n    /// @notice Performs a multiplexer operation between two euint128 values based on a selector\n    /// @dev If input1 is true, returns input2, otherwise returns input3. All inputs are initialized to defaults if not set.\n    /// @param input1 The selector of type ebool\n    /// @param input2 First choice of type euint128\n    /// @param input3 Second choice of type euint128\n    /// @return result of type euint128 containing the selected value\n    function select(ebool input1, euint128 input2, euint128 input3) internal returns (euint128) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n        if (!Common.isInitialized(input2)) {\n            input2 = asEuint128(0);\n        }\n        if (!Common.isInitialized(input3)) {\n            input3 = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.select(Utils.EUINT128_TFHE, input1, euint128.unwrap(input2), euint128.unwrap(input3)));\n    }\n\n    /// @notice Performs a multiplexer operation between two euint256 values based on a selector\n    /// @dev If input1 is true, returns input2, otherwise returns input3. All inputs are initialized to defaults if not set.\n    /// @param input1 The selector of type ebool\n    /// @param input2 First choice of type euint256\n    /// @param input3 Second choice of type euint256\n    /// @return result of type euint256 containing the selected value\n    function select(ebool input1, euint256 input2, euint256 input3) internal returns (euint256) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n        if (!Common.isInitialized(input2)) {\n            input2 = asEuint256(0);\n        }\n        if (!Common.isInitialized(input3)) {\n            input3 = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.select(Utils.EUINT256_TFHE, input1, euint256.unwrap(input2), euint256.unwrap(input3)));\n    }\n\n    /// @notice Performs a multiplexer operation between two eaddress values based on a selector\n    /// @dev If input1 is true, returns input2, otherwise returns input3. All inputs are initialized to defaults if not set.\n    /// @param input1 The selector of type ebool\n    /// @param input2 First choice of type eaddress\n    /// @param input3 Second choice of type eaddress\n    /// @return result of type eaddress containing the selected value\n    function select(ebool input1, eaddress input2, eaddress input3) internal returns (eaddress) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n        if (!Common.isInitialized(input2)) {\n            input2 = asEaddress(address(0));\n        }\n        if (!Common.isInitialized(input3)) {\n            input3 = asEaddress(address(0));\n        }\n\n        return eaddress.wrap(Impl.select(Utils.EADDRESS_TFHE, input1, eaddress.unwrap(input2), eaddress.unwrap(input3)));\n    }\n\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext.\n    /// @param input1 the input ciphertext\n    function not(ebool input1) internal returns (ebool) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEbool(false);\n        }\n\n        return ebool.wrap(Impl.not(Utils.EBOOL_TFHE, ebool.unwrap(input1)));\n    }\n\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext.\n    /// @param input1 the input ciphertext\n    function not(euint8 input1) internal returns (euint8) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.not(Utils.EUINT8_TFHE, euint8.unwrap(input1)));\n    }\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext.\n    /// @param input1 the input ciphertext\n    function not(euint16 input1) internal returns (euint16) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.not(Utils.EUINT16_TFHE, euint16.unwrap(input1)));\n    }\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext.\n    /// @param input1 the input ciphertext\n    function not(euint32 input1) internal returns (euint32) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.not(Utils.EUINT32_TFHE, euint32.unwrap(input1)));\n    }\n\n    /// @notice Performs the bitwise NOT operation on an encrypted 64-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      The operation inverts all bits of the input value.\n    /// @param input1 The input ciphertext to negate\n    /// @return An euint64 containing the bitwise NOT of the input\n    function not(euint64 input1) internal returns (euint64) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.not(Utils.EUINT64_TFHE, euint64.unwrap(input1)));\n    }\n\n    /// @notice Performs the bitwise NOT operation on an encrypted 128-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      The operation inverts all bits of the input value.\n    /// @param input1 The input ciphertext to negate\n    /// @return An euint128 containing the bitwise NOT of the input\n    function not(euint128 input1) internal returns (euint128) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.not(Utils.EUINT128_TFHE, euint128.unwrap(input1)));\n    }\n\n    /// @notice Performs the bitwise NOT operation on an encrypted 256-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      The operation inverts all bits of the input value.\n    /// @param input1 The input ciphertext to negate\n    /// @return An euint256 containing the bitwise NOT of the input\n    function not(euint256 input1) internal returns (euint256) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.not(Utils.EUINT256_TFHE, euint256.unwrap(input1)));\n    }\n\n    /// @notice Performs the square operation on an encrypted 8-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      Note: The result may overflow if input * input exceeds 8 bits.\n    /// @param input1 The input ciphertext to square\n    /// @return An euint8 containing the square of the input\n    function square(euint8 input1) internal returns (euint8) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n\n        return euint8.wrap(Impl.square(Utils.EUINT8_TFHE, euint8.unwrap(input1)));\n    }\n\n    /// @notice Performs the square operation on an encrypted 16-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      Note: The result may overflow if input * input exceeds 16 bits.\n    /// @param input1 The input ciphertext to square\n    /// @return An euint16 containing the square of the input\n    function square(euint16 input1) internal returns (euint16) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n\n        return euint16.wrap(Impl.square(Utils.EUINT16_TFHE, euint16.unwrap(input1)));\n    }\n\n    /// @notice Performs the square operation on an encrypted 32-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      Note: The result may overflow if input * input exceeds 32 bits.\n    /// @param input1 The input ciphertext to square\n    /// @return An euint32 containing the square of the input\n    function square(euint32 input1) internal returns (euint32) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n\n        return euint32.wrap(Impl.square(Utils.EUINT32_TFHE, euint32.unwrap(input1)));\n    }\n\n    /// @notice Performs the square operation on an encrypted 64-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      Note: The result may overflow if input * input exceeds 64 bits.\n    /// @param input1 The input ciphertext to square\n    /// @return An euint64 containing the square of the input\n    function square(euint64 input1) internal returns (euint64) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint64(0);\n        }\n\n        return euint64.wrap(Impl.square(Utils.EUINT64_TFHE, euint64.unwrap(input1)));\n    }\n\n    /// @notice Performs the square operation on an encrypted 128-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      Note: The result may overflow if input * input exceeds 128 bits.\n    /// @param input1 The input ciphertext to square\n    /// @return An euint128 containing the square of the input\n    function square(euint128 input1) internal returns (euint128) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint128(0);\n        }\n\n        return euint128.wrap(Impl.square(Utils.EUINT128_TFHE, euint128.unwrap(input1)));\n    }\n\n    /// @notice Performs the square operation on an encrypted 256-bit unsigned integer\n    /// @dev Verifies that the input is initialized, defaulting to 0 if not.\n    ///      Note: The result may overflow if input * input exceeds 256 bits.\n    /// @param input1 The input ciphertext to square\n    /// @return An euint256 containing the square of the input\n    function square(euint256 input1) internal returns (euint256) {\n        if (!Common.isInitialized(input1)) {\n            input1 = asEuint256(0);\n        }\n\n        return euint256.wrap(Impl.square(Utils.EUINT256_TFHE, euint256.unwrap(input1)));\n    }\n    /// @notice Generates a random value of a euint8 type for provided securityZone\n    /// @dev Generates a cryptographically secure random 8-bit unsigned integer in encrypted form.\n    ///      The generated value is fully encrypted and cannot be predicted by any party.\n    /// @param securityZone The security zone identifier to use for random value generation.\n    /// @return A randomly generated encrypted 8-bit unsigned integer (euint8)\n    function randomEuint8(int32 securityZone) internal returns (euint8) {\n        return euint8.wrap(Impl.random(Utils.EUINT8_TFHE, 0, securityZone));\n    }\n    /// @notice Generates a random value of a euint8 type\n    /// @dev Generates a cryptographically secure random 8-bit unsigned integer in encrypted form\n    ///      using the default security zone (0). The generated value is fully encrypted and\n    ///      cannot be predicted by any party.\n    /// @return A randomly generated encrypted 8-bit unsigned integer (euint8)\n    function randomEuint8() internal returns (euint8) {\n        return randomEuint8(0);\n    }\n    /// @notice Generates a random value of a euint16 type for provided securityZone\n    /// @dev Generates a cryptographically secure random 16-bit unsigned integer in encrypted form.\n    ///      The generated value is fully encrypted and cannot be predicted by any party.\n    /// @param securityZone The security zone identifier to use for random value generation.\n    /// @return A randomly generated encrypted 16-bit unsigned integer (euint16)\n    function randomEuint16(int32 securityZone) internal returns (euint16) {\n        return euint16.wrap(Impl.random(Utils.EUINT16_TFHE, 0, securityZone));\n    }\n    /// @notice Generates a random value of a euint16 type\n    /// @dev Generates a cryptographically secure random 16-bit unsigned integer in encrypted form\n    ///      using the default security zone (0). The generated value is fully encrypted and\n    ///      cannot be predicted by any party.\n    /// @return A randomly generated encrypted 16-bit unsigned integer (euint16)\n    function randomEuint16() internal returns (euint16) {\n        return randomEuint16(0);\n    }\n    /// @notice Generates a random value of a euint32 type for provided securityZone\n    /// @dev Generates a cryptographically secure random 32-bit unsigned integer in encrypted form.\n    ///      The generated value is fully encrypted and cannot be predicted by any party.\n    /// @param securityZone The security zone identifier to use for random value generation.\n    /// @return A randomly generated encrypted 32-bit unsigned integer (euint32)\n    function randomEuint32(int32 securityZone) internal returns (euint32) {\n        return euint32.wrap(Impl.random(Utils.EUINT32_TFHE, 0, securityZone));\n    }\n    /// @notice Generates a random value of a euint32 type\n    /// @dev Generates a cryptographically secure random 32-bit unsigned integer in encrypted form\n    ///      using the default security zone (0). The generated value is fully encrypted and\n    ///      cannot be predicted by any party.\n    /// @return A randomly generated encrypted 32-bit unsigned integer (euint32)\n    function randomEuint32() internal returns (euint32) {\n        return randomEuint32(0);\n    }\n    /// @notice Generates a random value of a euint64 type for provided securityZone\n    /// @dev Generates a cryptographically secure random 64-bit unsigned integer in encrypted form.\n    ///      The generated value is fully encrypted and cannot be predicted by any party.\n    /// @param securityZone The security zone identifier to use for random value generation.\n    /// @return A randomly generated encrypted 64-bit unsigned integer (euint64)\n    function randomEuint64(int32 securityZone) internal returns (euint64) {\n        return euint64.wrap(Impl.random(Utils.EUINT64_TFHE, 0, securityZone));\n    }\n    /// @notice Generates a random value of a euint64 type\n    /// @dev Generates a cryptographically secure random 64-bit unsigned integer in encrypted form\n    ///      using the default security zone (0). The generated value is fully encrypted and\n    ///      cannot be predicted by any party.\n    /// @return A randomly generated encrypted 64-bit unsigned integer (euint64)\n    function randomEuint64() internal returns (euint64) {\n        return randomEuint64(0);\n    }\n    /// @notice Generates a random value of a euint128 type for provided securityZone\n    /// @dev Generates a cryptographically secure random 128-bit unsigned integer in encrypted form.\n    ///      The generated value is fully encrypted and cannot be predicted by any party.\n    /// @param securityZone The security zone identifier to use for random value generation.\n    /// @return A randomly generated encrypted 128-bit unsigned integer (euint128)\n    function randomEuint128(int32 securityZone) internal returns (euint128) {\n        return euint128.wrap(Impl.random(Utils.EUINT128_TFHE, 0, securityZone));\n    }\n    /// @notice Generates a random value of a euint128 type\n    /// @dev Generates a cryptographically secure random 128-bit unsigned integer in encrypted form\n    ///      using the default security zone (0). The generated value is fully encrypted and\n    ///      cannot be predicted by any party.\n    /// @return A randomly generated encrypted 128-bit unsigned integer (euint128)\n    function randomEuint128() internal returns (euint128) {\n        return randomEuint128(0);\n    }\n    /// @notice Generates a random value of a euint256 type for provided securityZone\n    /// @dev Generates a cryptographically secure random 256-bit unsigned integer in encrypted form.\n    ///      The generated value is fully encrypted and cannot be predicted by any party.\n    /// @param securityZone The security zone identifier to use for random value generation.\n    /// @return A randomly generated encrypted 256-bit unsigned integer (euint256)\n    function randomEuint256(int32 securityZone) internal returns (euint256) {\n        return euint256.wrap(Impl.random(Utils.EUINT256_TFHE, 0, securityZone));\n    }\n    /// @notice Generates a random value of a euint256 type\n    /// @dev Generates a cryptographically secure random 256-bit unsigned integer in encrypted form\n    ///      using the default security zone (0). The generated value is fully encrypted and\n    ///      cannot be predicted by any party.\n    /// @return A randomly generated encrypted 256-bit unsigned integer (euint256)\n    function randomEuint256() internal returns (euint256) {\n        return randomEuint256(0);\n    }\n\n    /// @notice Verifies and converts an inEbool input to an ebool encrypted type\n    /// @dev Verifies the input signature and security parameters before converting to the encrypted type\n    /// @param value The input value containing hash, type, security zone and signature\n    /// @return An ebool containing the verified encrypted value\n    function asEbool(InEbool memory value) internal returns (ebool) {\n        uint8 expectedUtype = Utils.EBOOL_TFHE;\n        if (value.utype != expectedUtype) {\n            revert InvalidEncryptedInput(value.utype, expectedUtype);\n        }\n\n        return ebool.wrap(Impl.verifyInput(Utils.inputFromEbool(value)));\n    }\n\n    /// @notice Verifies and converts an InEuint8 input to an euint8 encrypted type\n    /// @dev Verifies the input signature and security parameters before converting to the encrypted type\n    /// @param value The input value containing hash, type, security zone and signature\n    /// @return An euint8 containing the verified encrypted value\n    function asEuint8(InEuint8 memory value) internal returns (euint8) {\n        uint8 expectedUtype = Utils.EUINT8_TFHE;\n        if (value.utype != expectedUtype) {\n            revert InvalidEncryptedInput(value.utype, expectedUtype);\n        }\n\n\n        return euint8.wrap(Impl.verifyInput(Utils.inputFromEuint8(value)));\n    }\n\n    /// @notice Verifies and converts an InEuint16 input to an euint16 encrypted type\n    /// @dev Verifies the input signature and security parameters before converting to the encrypted type\n    /// @param value The input value containing hash, type, security zone and signature\n    /// @return An euint16 containing the verified encrypted value\n    function asEuint16(InEuint16 memory value) internal returns (euint16) {\n        uint8 expectedUtype = Utils.EUINT16_TFHE;\n        if (value.utype != expectedUtype) {\n            revert InvalidEncryptedInput(value.utype, expectedUtype);\n        }\n\n\n        return euint16.wrap(Impl.verifyInput(Utils.inputFromEuint16(value)));\n    }\n\n    /// @notice Verifies and converts an InEuint32 input to an euint32 encrypted type\n    /// @dev Verifies the input signature and security parameters before converting to the encrypted type\n    /// @param value The input value containing hash, type, security zone and signature\n    /// @return An euint32 containing the verified encrypted value\n    function asEuint32(InEuint32 memory value) internal returns (euint32) {\n        uint8 expectedUtype = Utils.EUINT32_TFHE;\n        if (value.utype != expectedUtype) {\n            revert InvalidEncryptedInput(value.utype, expectedUtype);\n        }\n\n\n        return euint32.wrap(Impl.verifyInput(Utils.inputFromEuint32(value)));\n    }\n\n    /// @notice Verifies and converts an InEuint64 input to an euint64 encrypted type\n    /// @dev Verifies the input signature and security parameters before converting to the encrypted type\n    /// @param value The input value containing hash, type, security zone and signature\n    /// @return An euint64 containing the verified encrypted value\n    function asEuint64(InEuint64 memory value) internal returns (euint64) {\n        uint8 expectedUtype = Utils.EUINT64_TFHE;\n        if (value.utype != expectedUtype) {\n            revert InvalidEncryptedInput(value.utype, expectedUtype);\n        }\n\n\n        return euint64.wrap(Impl.verifyInput(Utils.inputFromEuint64(value)));\n    }\n\n    /// @notice Verifies and converts an InEuint128 input to an euint128 encrypted type\n    /// @dev Verifies the input signature and security parameters before converting to the encrypted type\n    /// @param value The input value containing hash, type, security zone and signature\n    /// @return An euint128 containing the verified encrypted value\n    function asEuint128(InEuint128 memory value) internal returns (euint128) {\n        uint8 expectedUtype = Utils.EUINT128_TFHE;\n        if (value.utype != expectedUtype) {\n            revert InvalidEncryptedInput(value.utype, expectedUtype);\n        }\n\n\n        return euint128.wrap(Impl.verifyInput(Utils.inputFromEuint128(value)));\n    }\n\n    /// @notice Verifies and converts an InEuint256 input to an euint256 encrypted type\n    /// @dev Verifies the input signature and security parameters before converting to the encrypted type\n    /// @param value The input value containing hash, type, security zone and signature\n    /// @return An euint256 containing the verified encrypted value\n    function asEuint256(InEuint256 memory value) internal returns (euint256) {\n        uint8 expectedUtype = Utils.EUINT256_TFHE;\n        if (value.utype != expectedUtype) {\n            revert InvalidEncryptedInput(value.utype, expectedUtype);\n        }\n\n\n        return euint256.wrap(Impl.verifyInput(Utils.inputFromEuint256(value)));\n    }\n\n    /// @notice Verifies and converts an InEaddress input to an eaddress encrypted type\n    /// @dev Verifies the input signature and security parameters before converting to the encrypted type\n    /// @param value The input value containing hash, type, security zone and signature\n    /// @return An eaddress containing the verified encrypted value\n    function asEaddress(InEaddress memory value) internal returns (eaddress) {\n        uint8 expectedUtype = Utils.EADDRESS_TFHE;\n        if (value.utype != expectedUtype) {\n            revert InvalidEncryptedInput(value.utype, expectedUtype);\n        }\n\n\n        return eaddress.wrap(Impl.verifyInput(Utils.inputFromEaddress(value)));\n    }\n\n    // ********** TYPE CASTING ************* //\n    /// @notice Converts a ebool to an euint8\n    function asEuint8(ebool value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Utils.EUINT8_TFHE));\n    }\n    /// @notice Converts a ebool to an euint16\n    function asEuint16(ebool value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(ebool.unwrap(value), Utils.EUINT16_TFHE));\n    }\n    /// @notice Converts a ebool to an euint32\n    function asEuint32(ebool value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(ebool.unwrap(value), Utils.EUINT32_TFHE));\n    }\n    /// @notice Converts a ebool to an euint64\n    function asEuint64(ebool value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(ebool.unwrap(value), Utils.EUINT64_TFHE));\n    }\n    /// @notice Converts a ebool to an euint128\n    function asEuint128(ebool value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(ebool.unwrap(value), Utils.EUINT128_TFHE));\n    }\n    /// @notice Converts a ebool to an euint256\n    function asEuint256(ebool value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(ebool.unwrap(value), Utils.EUINT256_TFHE));\n    }\n\n    /// @notice Converts a euint8 to an ebool\n    function asEbool(euint8 value) internal returns (ebool) {\n        return ne(value, asEuint8(0));\n    }\n    /// @notice Converts a euint8 to an euint16\n    function asEuint16(euint8 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Utils.EUINT16_TFHE));\n    }\n    /// @notice Converts a euint8 to an euint32\n    function asEuint32(euint8 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Utils.EUINT32_TFHE));\n    }\n    /// @notice Converts a euint8 to an euint64\n    function asEuint64(euint8 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Utils.EUINT64_TFHE));\n    }\n    /// @notice Converts a euint8 to an euint128\n    function asEuint128(euint8 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Utils.EUINT128_TFHE));\n    }\n    /// @notice Converts a euint8 to an euint256\n    function asEuint256(euint8 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Utils.EUINT256_TFHE));\n    }\n\n    /// @notice Converts a euint16 to an ebool\n    function asEbool(euint16 value) internal returns (ebool) {\n        return ne(value, asEuint16(0));\n    }\n    /// @notice Converts a euint16 to an euint8\n    function asEuint8(euint16 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Utils.EUINT8_TFHE));\n    }\n    /// @notice Converts a euint16 to an euint32\n    function asEuint32(euint16 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Utils.EUINT32_TFHE));\n    }\n    /// @notice Converts a euint16 to an euint64\n    function asEuint64(euint16 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Utils.EUINT64_TFHE));\n    }\n    /// @notice Converts a euint16 to an euint128\n    function asEuint128(euint16 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Utils.EUINT128_TFHE));\n    }\n    /// @notice Converts a euint16 to an euint256\n    function asEuint256(euint16 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Utils.EUINT256_TFHE));\n    }\n\n    /// @notice Converts a euint32 to an ebool\n    function asEbool(euint32 value) internal returns (ebool) {\n        return ne(value, asEuint32(0));\n    }\n    /// @notice Converts a euint32 to an euint8\n    function asEuint8(euint32 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Utils.EUINT8_TFHE));\n    }\n    /// @notice Converts a euint32 to an euint16\n    function asEuint16(euint32 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Utils.EUINT16_TFHE));\n    }\n    /// @notice Converts a euint32 to an euint64\n    function asEuint64(euint32 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Utils.EUINT64_TFHE));\n    }\n    /// @notice Converts a euint32 to an euint128\n    function asEuint128(euint32 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Utils.EUINT128_TFHE));\n    }\n    /// @notice Converts a euint32 to an euint256\n    function asEuint256(euint32 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Utils.EUINT256_TFHE));\n    }\n\n    /// @notice Converts a euint64 to an ebool\n    function asEbool(euint64 value) internal returns (ebool) {\n        return ne(value, asEuint64(0));\n    }\n    /// @notice Converts a euint64 to an euint8\n    function asEuint8(euint64 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Utils.EUINT8_TFHE));\n    }\n    /// @notice Converts a euint64 to an euint16\n    function asEuint16(euint64 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Utils.EUINT16_TFHE));\n    }\n    /// @notice Converts a euint64 to an euint32\n    function asEuint32(euint64 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Utils.EUINT32_TFHE));\n    }\n    /// @notice Converts a euint64 to an euint128\n    function asEuint128(euint64 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Utils.EUINT128_TFHE));\n    }\n    /// @notice Converts a euint64 to an euint256\n    function asEuint256(euint64 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Utils.EUINT256_TFHE));\n    }\n\n    /// @notice Converts a euint128 to an ebool\n    function asEbool(euint128 value) internal returns (ebool) {\n        return ne(value, asEuint128(0));\n    }\n    /// @notice Converts a euint128 to an euint8\n    function asEuint8(euint128 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Utils.EUINT8_TFHE));\n    }\n    /// @notice Converts a euint128 to an euint16\n    function asEuint16(euint128 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Utils.EUINT16_TFHE));\n    }\n    /// @notice Converts a euint128 to an euint32\n    function asEuint32(euint128 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Utils.EUINT32_TFHE));\n    }\n    /// @notice Converts a euint128 to an euint64\n    function asEuint64(euint128 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Utils.EUINT64_TFHE));\n    }\n    /// @notice Converts a euint128 to an euint256\n    function asEuint256(euint128 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Utils.EUINT256_TFHE));\n    }\n\n    /// @notice Converts a euint256 to an ebool\n    function asEbool(euint256 value) internal returns (ebool) {\n        return ne(value, asEuint256(0));\n    }\n    /// @notice Converts a euint256 to an euint8\n    function asEuint8(euint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Utils.EUINT8_TFHE));\n    }\n    /// @notice Converts a euint256 to an euint16\n    function asEuint16(euint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Utils.EUINT16_TFHE));\n    }\n    /// @notice Converts a euint256 to an euint32\n    function asEuint32(euint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Utils.EUINT32_TFHE));\n    }\n    /// @notice Converts a euint256 to an euint64\n    function asEuint64(euint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Utils.EUINT64_TFHE));\n    }\n    /// @notice Converts a euint256 to an euint128\n    function asEuint128(euint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Utils.EUINT128_TFHE));\n    }\n    /// @notice Converts a euint256 to an eaddress\n    function asEaddress(euint256 value) internal returns (eaddress) {\n        return eaddress.wrap(Impl.cast(euint256.unwrap(value), Utils.EADDRESS_TFHE));\n    }\n\n    /// @notice Converts a eaddress to an ebool\n    function asEbool(eaddress value) internal returns (ebool) {\n        return ne(value, asEaddress(address(0)));\n    }\n    /// @notice Converts a eaddress to an euint8\n    function asEuint8(eaddress value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(eaddress.unwrap(value), Utils.EUINT8_TFHE));\n    }\n    /// @notice Converts a eaddress to an euint16\n    function asEuint16(eaddress value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(eaddress.unwrap(value), Utils.EUINT16_TFHE));\n    }\n    /// @notice Converts a eaddress to an euint32\n    function asEuint32(eaddress value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(eaddress.unwrap(value), Utils.EUINT32_TFHE));\n    }\n    /// @notice Converts a eaddress to an euint64\n    function asEuint64(eaddress value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(eaddress.unwrap(value), Utils.EUINT64_TFHE));\n    }\n    /// @notice Converts a eaddress to an euint128\n    function asEuint128(eaddress value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(eaddress.unwrap(value), Utils.EUINT128_TFHE));\n    }\n    /// @notice Converts a eaddress to an euint256\n    function asEuint256(eaddress value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(eaddress.unwrap(value), Utils.EUINT256_TFHE));\n    }\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    /// @return A ciphertext representation of the input\n    function asEbool(bool value) internal returns (ebool) {\n        return asEbool(value, 0);\n    }\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool, specifying security zone\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    /// @return A ciphertext representation of the input\n    function asEbool(bool value, int32 securityZone) internal returns (ebool) {\n        uint256 sVal = 0;\n        if (value) {\n            sVal = 1;\n        }\n        uint256 ct = Impl.trivialEncrypt(sVal, Utils.EBOOL_TFHE, securityZone);\n        return ebool.wrap(ct);\n    }\n    /// @notice Converts a uint256 to an euint8\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint8(uint256 value) internal returns (euint8) {\n        return asEuint8(value, 0);\n    }\n    /// @notice Converts a uint256 to an euint8, specifying security zone\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint8(uint256 value, int32 securityZone) internal returns (euint8) {\n        uint256 ct = Impl.trivialEncrypt(value, Utils.EUINT8_TFHE, securityZone);\n        return euint8.wrap(ct);\n    }\n    /// @notice Converts a uint256 to an euint16\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint16(uint256 value) internal returns (euint16) {\n        return asEuint16(value, 0);\n    }\n    /// @notice Converts a uint256 to an euint16, specifying security zone\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint16(uint256 value, int32 securityZone) internal returns (euint16) {\n        uint256 ct = Impl.trivialEncrypt(value, Utils.EUINT16_TFHE, securityZone);\n        return euint16.wrap(ct);\n    }\n    /// @notice Converts a uint256 to an euint32\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint32(uint256 value) internal returns (euint32) {\n        return asEuint32(value, 0);\n    }\n    /// @notice Converts a uint256 to an euint32, specifying security zone\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint32(uint256 value, int32 securityZone) internal returns (euint32) {\n        uint256 ct = Impl.trivialEncrypt(value, Utils.EUINT32_TFHE, securityZone);\n        return euint32.wrap(ct);\n    }\n    /// @notice Converts a uint256 to an euint64\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint64(uint256 value) internal returns (euint64) {\n        return asEuint64(value, 0);\n    }\n    /// @notice Converts a uint256 to an euint64, specifying security zone\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint64(uint256 value, int32 securityZone) internal returns (euint64) {\n        uint256 ct = Impl.trivialEncrypt(value, Utils.EUINT64_TFHE, securityZone);\n        return euint64.wrap(ct);\n    }\n    /// @notice Converts a uint256 to an euint128\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint128(uint256 value) internal returns (euint128) {\n        return asEuint128(value, 0);\n    }\n    /// @notice Converts a uint256 to an euint128, specifying security zone\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint128(uint256 value, int32 securityZone) internal returns (euint128) {\n        uint256 ct = Impl.trivialEncrypt(value, Utils.EUINT128_TFHE, securityZone);\n        return euint128.wrap(ct);\n    }\n    /// @notice Converts a uint256 to an euint256\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint256(uint256 value) internal returns (euint256) {\n        return asEuint256(value, 0);\n    }\n    /// @notice Converts a uint256 to an euint256, specifying security zone\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    function asEuint256(uint256 value, int32 securityZone) internal returns (euint256) {\n        uint256 ct = Impl.trivialEncrypt(value, Utils.EUINT256_TFHE, securityZone);\n        return euint256.wrap(ct);\n    }\n    /// @notice Converts a address to an eaddress\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    /// Allows for a better user experience when working with eaddresses\n    function asEaddress(address value) internal returns (eaddress) {\n        return asEaddress(value, 0);\n    }\n    /// @notice Converts a address to an eaddress, specifying security zone\n    /// @dev Privacy: The input value is public, therefore the resulting ciphertext should be considered public until involved in an fhe operation\n    /// Allows for a better user experience when working with eaddresses\n    function asEaddress(address value, int32 securityZone) internal returns (eaddress) {\n        uint256 ct = Impl.trivialEncrypt(uint256(uint160(value)), Utils.EADDRESS_TFHE, securityZone);\n        return eaddress.wrap(ct);\n    }\n\n    /// @notice Grants permission to an account to operate on the encrypted boolean value\n    /// @dev Allows the specified account to access the ciphertext\n    /// @param ctHash The encrypted boolean value to grant access to\n    /// @param account The address being granted permission\n    function allow(ebool ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(ebool.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants permission to an account to operate on the encrypted 8-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext\n    /// @param ctHash The encrypted uint8 value to grant access to\n    /// @param account The address being granted permission\n    function allow(euint8 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint8.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants permission to an account to operate on the encrypted 16-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext\n    /// @param ctHash The encrypted uint16 value to grant access to\n    /// @param account The address being granted permission\n    function allow(euint16 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint16.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants permission to an account to operate on the encrypted 32-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext\n    /// @param ctHash The encrypted uint32 value to grant access to\n    /// @param account The address being granted permission\n    function allow(euint32 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint32.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants permission to an account to operate on the encrypted 64-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext\n    /// @param ctHash The encrypted uint64 value to grant access to\n    /// @param account The address being granted permission\n    function allow(euint64 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint64.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants permission to an account to operate on the encrypted 128-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext\n    /// @param ctHash The encrypted uint128 value to grant access to\n    /// @param account The address being granted permission\n    function allow(euint128 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint128.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants permission to an account to operate on the encrypted 256-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext\n    /// @param ctHash The encrypted uint256 value to grant access to\n    /// @param account The address being granted permission\n    function allow(euint256 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint256.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants permission to an account to operate on the encrypted address\n    /// @dev Allows the specified account to access the ciphertext\n    /// @param ctHash The encrypted address value to grant access to\n    /// @param account The address being granted permission\n    function allow(eaddress ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(eaddress.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants global permission to operate on the encrypted boolean value\n    /// @dev Allows all accounts to access the ciphertext\n    /// @param ctHash The encrypted boolean value to grant global access to\n    function allowGlobal(ebool ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowGlobal(ebool.unwrap(ctHash));\n    }\n\n    /// @notice Grants global permission to operate on the encrypted 8-bit unsigned integer\n    /// @dev Allows all accounts to access the ciphertext\n    /// @param ctHash The encrypted uint8 value to grant global access to\n    function allowGlobal(euint8 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowGlobal(euint8.unwrap(ctHash));\n    }\n\n    /// @notice Grants global permission to operate on the encrypted 16-bit unsigned integer\n    /// @dev Allows all accounts to access the ciphertext\n    /// @param ctHash The encrypted uint16 value to grant global access to\n    function allowGlobal(euint16 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowGlobal(euint16.unwrap(ctHash));\n    }\n\n    /// @notice Grants global permission to operate on the encrypted 32-bit unsigned integer\n    /// @dev Allows all accounts to access the ciphertext\n    /// @param ctHash The encrypted uint32 value to grant global access to\n    function allowGlobal(euint32 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowGlobal(euint32.unwrap(ctHash));\n    }\n\n    /// @notice Grants global permission to operate on the encrypted 64-bit unsigned integer\n    /// @dev Allows all accounts to access the ciphertext\n    /// @param ctHash The encrypted uint64 value to grant global access to\n    function allowGlobal(euint64 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowGlobal(euint64.unwrap(ctHash));\n    }\n\n    /// @notice Grants global permission to operate on the encrypted 128-bit unsigned integer\n    /// @dev Allows all accounts to access the ciphertext\n    /// @param ctHash The encrypted uint128 value to grant global access to\n    function allowGlobal(euint128 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowGlobal(euint128.unwrap(ctHash));\n    }\n\n    /// @notice Grants global permission to operate on the encrypted 256-bit unsigned integer\n    /// @dev Allows all accounts to access the ciphertext\n    /// @param ctHash The encrypted uint256 value to grant global access to\n    function allowGlobal(euint256 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowGlobal(euint256.unwrap(ctHash));\n    }\n\n    /// @notice Grants global permission to operate on the encrypted address\n    /// @dev Allows all accounts to access the ciphertext\n    /// @param ctHash The encrypted address value to grant global access to\n    function allowGlobal(eaddress ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowGlobal(eaddress.unwrap(ctHash));\n    }\n\n    /// @notice Checks if an account has permission to operate on the encrypted boolean value\n    /// @dev Returns whether the specified account can access the ciphertext\n    /// @param ctHash The encrypted boolean value to check access for\n    /// @param account The address to check permissions for\n    /// @return True if the account has permission, false otherwise\n    function isAllowed(ebool ctHash, address account) internal returns (bool) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).isAllowed(ebool.unwrap(ctHash), account);\n    }\n\n    /// @notice Checks if an account has permission to operate on the encrypted 8-bit unsigned integer\n    /// @dev Returns whether the specified account can access the ciphertext\n    /// @param ctHash The encrypted uint8 value to check access for\n    /// @param account The address to check permissions for\n    /// @return True if the account has permission, false otherwise\n    function isAllowed(euint8 ctHash, address account) internal returns (bool) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).isAllowed(euint8.unwrap(ctHash), account);\n    }\n\n    /// @notice Checks if an account has permission to operate on the encrypted 16-bit unsigned integer\n    /// @dev Returns whether the specified account can access the ciphertext\n    /// @param ctHash The encrypted uint16 value to check access for\n    /// @param account The address to check permissions for\n    /// @return True if the account has permission, false otherwise\n    function isAllowed(euint16 ctHash, address account) internal returns (bool) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).isAllowed(euint16.unwrap(ctHash), account);\n    }\n\n    /// @notice Checks if an account has permission to operate on the encrypted 32-bit unsigned integer\n    /// @dev Returns whether the specified account can access the ciphertext\n    /// @param ctHash The encrypted uint32 value to check access for\n    /// @param account The address to check permissions for\n    /// @return True if the account has permission, false otherwise\n    function isAllowed(euint32 ctHash, address account) internal returns (bool) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).isAllowed(euint32.unwrap(ctHash), account);\n    }\n\n    /// @notice Checks if an account has permission to operate on the encrypted 64-bit unsigned integer\n    /// @dev Returns whether the specified account can access the ciphertext\n    /// @param ctHash The encrypted uint64 value to check access for\n    /// @param account The address to check permissions for\n    /// @return True if the account has permission, false otherwise\n    function isAllowed(euint64 ctHash, address account) internal returns (bool) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).isAllowed(euint64.unwrap(ctHash), account);\n    }\n\n    /// @notice Checks if an account has permission to operate on the encrypted 128-bit unsigned integer\n    /// @dev Returns whether the specified account can access the ciphertext\n    /// @param ctHash The encrypted uint128 value to check access for\n    /// @param account The address to check permissions for\n    /// @return True if the account has permission, false otherwise\n    function isAllowed(euint128 ctHash, address account) internal returns (bool) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).isAllowed(euint128.unwrap(ctHash), account);\n    }\n\n    /// @notice Checks if an account has permission to operate on the encrypted 256-bit unsigned integer\n    /// @dev Returns whether the specified account can access the ciphertext\n    /// @param ctHash The encrypted uint256 value to check access for\n    /// @param account The address to check permissions for\n    /// @return True if the account has permission, false otherwise\n    function isAllowed(euint256 ctHash, address account) internal returns (bool) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).isAllowed(euint256.unwrap(ctHash), account);\n    }\n\n    /// @notice Checks if an account has permission to operate on the encrypted address\n    /// @dev Returns whether the specified account can access the ciphertext\n    /// @param ctHash The encrypted address value to check access for\n    /// @param account The address to check permissions for\n    /// @return True if the account has permission, false otherwise\n    function isAllowed(eaddress ctHash, address account) internal returns (bool) {\n        return ITaskManager(TASK_MANAGER_ADDRESS).isAllowed(eaddress.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants permission to the current contract to operate on the encrypted boolean value\n    /// @dev Allows this contract to access the ciphertext\n    /// @param ctHash The encrypted boolean value to grant access to\n    function allowThis(ebool ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(ebool.unwrap(ctHash), address(this));\n    }\n\n    /// @notice Grants permission to the current contract to operate on the encrypted 8-bit unsigned integer\n    /// @dev Allows this contract to access the ciphertext\n    /// @param ctHash The encrypted uint8 value to grant access to\n    function allowThis(euint8 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint8.unwrap(ctHash), address(this));\n    }\n\n    /// @notice Grants permission to the current contract to operate on the encrypted 16-bit unsigned integer\n    /// @dev Allows this contract to access the ciphertext\n    /// @param ctHash The encrypted uint16 value to grant access to\n    function allowThis(euint16 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint16.unwrap(ctHash), address(this));\n    }\n\n    /// @notice Grants permission to the current contract to operate on the encrypted 32-bit unsigned integer\n    /// @dev Allows this contract to access the ciphertext\n    /// @param ctHash The encrypted uint32 value to grant access to\n    function allowThis(euint32 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint32.unwrap(ctHash), address(this));\n    }\n\n    /// @notice Grants permission to the current contract to operate on the encrypted 64-bit unsigned integer\n    /// @dev Allows this contract to access the ciphertext\n    /// @param ctHash The encrypted uint64 value to grant access to\n    function allowThis(euint64 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint64.unwrap(ctHash), address(this));\n    }\n\n    /// @notice Grants permission to the current contract to operate on the encrypted 128-bit unsigned integer\n    /// @dev Allows this contract to access the ciphertext\n    /// @param ctHash The encrypted uint128 value to grant access to\n    function allowThis(euint128 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint128.unwrap(ctHash), address(this));\n    }\n\n    /// @notice Grants permission to the current contract to operate on the encrypted 256-bit unsigned integer\n    /// @dev Allows this contract to access the ciphertext\n    /// @param ctHash The encrypted uint256 value to grant access to\n    function allowThis(euint256 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint256.unwrap(ctHash), address(this));\n    }\n\n    /// @notice Grants permission to the current contract to operate on the encrypted address\n    /// @dev Allows this contract to access the ciphertext\n    /// @param ctHash The encrypted address value to grant access to\n    function allowThis(eaddress ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(eaddress.unwrap(ctHash), address(this));\n    }\n\n    /// @notice Grants permission to the message sender to operate on the encrypted boolean value\n    /// @dev Allows the transaction sender to access the ciphertext\n    /// @param ctHash The encrypted boolean value to grant access to\n    function allowSender(ebool ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(ebool.unwrap(ctHash), msg.sender);\n    }\n\n    /// @notice Grants permission to the message sender to operate on the encrypted 8-bit unsigned integer\n    /// @dev Allows the transaction sender to access the ciphertext\n    /// @param ctHash The encrypted uint8 value to grant access to\n    function allowSender(euint8 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint8.unwrap(ctHash), msg.sender);\n    }\n\n    /// @notice Grants permission to the message sender to operate on the encrypted 16-bit unsigned integer\n    /// @dev Allows the transaction sender to access the ciphertext\n    /// @param ctHash The encrypted uint16 value to grant access to\n    function allowSender(euint16 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint16.unwrap(ctHash), msg.sender);\n    }\n\n    /// @notice Grants permission to the message sender to operate on the encrypted 32-bit unsigned integer\n    /// @dev Allows the transaction sender to access the ciphertext\n    /// @param ctHash The encrypted uint32 value to grant access to\n    function allowSender(euint32 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint32.unwrap(ctHash), msg.sender);\n    }\n\n    /// @notice Grants permission to the message sender to operate on the encrypted 64-bit unsigned integer\n    /// @dev Allows the transaction sender to access the ciphertext\n    /// @param ctHash The encrypted uint64 value to grant access to\n    function allowSender(euint64 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint64.unwrap(ctHash), msg.sender);\n    }\n\n    /// @notice Grants permission to the message sender to operate on the encrypted 128-bit unsigned integer\n    /// @dev Allows the transaction sender to access the ciphertext\n    /// @param ctHash The encrypted uint128 value to grant access to\n    function allowSender(euint128 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint128.unwrap(ctHash), msg.sender);\n    }\n\n    /// @notice Grants permission to the message sender to operate on the encrypted 256-bit unsigned integer\n    /// @dev Allows the transaction sender to access the ciphertext\n    /// @param ctHash The encrypted uint256 value to grant access to\n    function allowSender(euint256 ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(euint256.unwrap(ctHash), msg.sender);\n    }\n\n    /// @notice Grants permission to the message sender to operate on the encrypted address\n    /// @dev Allows the transaction sender to access the ciphertext\n    /// @param ctHash The encrypted address value to grant access to\n    function allowSender(eaddress ctHash) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allow(eaddress.unwrap(ctHash), msg.sender);\n    }\n\n    /// @notice Grants temporary permission to an account to operate on the encrypted boolean value\n    /// @dev Allows the specified account to access the ciphertext for the current transaction only\n    /// @param ctHash The encrypted boolean value to grant temporary access to\n    /// @param account The address being granted temporary permission\n    function allowTransient(ebool ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowTransient(ebool.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants temporary permission to an account to operate on the encrypted 8-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext for the current transaction only\n    /// @param ctHash The encrypted uint8 value to grant temporary access to\n    /// @param account The address being granted temporary permission\n    function allowTransient(euint8 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowTransient(euint8.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants temporary permission to an account to operate on the encrypted 16-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext for the current transaction only\n    /// @param ctHash The encrypted uint16 value to grant temporary access to\n    /// @param account The address being granted temporary permission\n    function allowTransient(euint16 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowTransient(euint16.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants temporary permission to an account to operate on the encrypted 32-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext for the current transaction only\n    /// @param ctHash The encrypted uint32 value to grant temporary access to\n    /// @param account The address being granted temporary permission\n    function allowTransient(euint32 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowTransient(euint32.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants temporary permission to an account to operate on the encrypted 64-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext for the current transaction only\n    /// @param ctHash The encrypted uint64 value to grant temporary access to\n    /// @param account The address being granted temporary permission\n    function allowTransient(euint64 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowTransient(euint64.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants temporary permission to an account to operate on the encrypted 128-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext for the current transaction only\n    /// @param ctHash The encrypted uint128 value to grant temporary access to\n    /// @param account The address being granted temporary permission\n    function allowTransient(euint128 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowTransient(euint128.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants temporary permission to an account to operate on the encrypted 256-bit unsigned integer\n    /// @dev Allows the specified account to access the ciphertext for the current transaction only\n    /// @param ctHash The encrypted uint256 value to grant temporary access to\n    /// @param account The address being granted temporary permission\n    function allowTransient(euint256 ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowTransient(euint256.unwrap(ctHash), account);\n    }\n\n    /// @notice Grants temporary permission to an account to operate on the encrypted address\n    /// @dev Allows the specified account to access the ciphertext for the current transaction only\n    /// @param ctHash The encrypted address value to grant temporary access to\n    /// @param account The address being granted temporary permission\n    function allowTransient(eaddress ctHash, address account) internal {\n        ITaskManager(TASK_MANAGER_ADDRESS).allowTransient(eaddress.unwrap(ctHash), account);\n    }\n\n\n}\n// ********** BINDING DEFS ************* //\n\nusing BindingsEbool for ebool global;\nlibrary BindingsEbool {\n\n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return the result of the eq\n    function eq(ebool lhs, ebool rhs) internal returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n\n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return the result of the ne\n    function ne(ebool lhs, ebool rhs) internal returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n\n    /// @notice Performs the not operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the not\n    function not(ebool lhs) internal returns (ebool) {\n        return FHE.not(lhs);\n    }\n\n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return the result of the and\n    function and(ebool lhs, ebool rhs) internal returns (ebool) {\n        return FHE.and(lhs, rhs);\n    }\n\n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return the result of the or\n    function or(ebool lhs, ebool rhs) internal returns (ebool) {\n        return FHE.or(lhs, rhs);\n    }\n\n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @param rhs second input of type ebool\n    /// @return the result of the xor\n    function xor(ebool lhs, ebool rhs) internal returns (ebool) {\n        return FHE.xor(lhs, rhs);\n    }\n    function toU8(ebool value) internal returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(ebool value) internal returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(ebool value) internal returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function toU64(ebool value) internal returns (euint64) {\n        return FHE.asEuint64(value);\n    }\n    function toU128(ebool value) internal returns (euint128) {\n        return FHE.asEuint128(value);\n    }\n    function toU256(ebool value) internal returns (euint256) {\n        return FHE.asEuint256(value);\n    }\n    function decrypt(ebool value) internal {\n        FHE.decrypt(value);\n    }\n    function allow(ebool ctHash, address account) internal {\n        FHE.allow(ctHash, account);\n    }\n    function isAllowed(ebool ctHash, address account) internal returns (bool) {\n        return FHE.isAllowed(ctHash, account);\n    }\n    function allowThis(ebool ctHash) internal {\n        FHE.allowThis(ctHash);\n    }\n    function allowGlobal(ebool ctHash) internal {\n        FHE.allowGlobal(ctHash);\n    }\n    function allowSender(ebool ctHash) internal {\n        FHE.allowSender(ctHash);\n    }\n    function allowTransient(ebool ctHash, address account) internal {\n        FHE.allowTransient(ctHash, account);\n    }\n}\n\nusing BindingsEuint8 for euint8 global;\nlibrary BindingsEuint8 {\n\n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the add\n    function add(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.add(lhs, rhs);\n    }\n\n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the mul\n    function mul(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.mul(lhs, rhs);\n    }\n\n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the div\n    function div(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.div(lhs, rhs);\n    }\n\n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the sub\n    function sub(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.sub(lhs, rhs);\n    }\n\n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the eq\n    function eq(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n\n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the ne\n    function ne(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n\n    /// @notice Performs the not operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the not\n    function not(euint8 lhs) internal returns (euint8) {\n        return FHE.not(lhs);\n    }\n\n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the and\n    function and(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.and(lhs, rhs);\n    }\n\n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the or\n    function or(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.or(lhs, rhs);\n    }\n\n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the xor\n    function xor(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.xor(lhs, rhs);\n    }\n\n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the gt\n    function gt(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n\n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the gte\n    function gte(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n\n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the lt\n    function lt(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n\n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the lte\n    function lte(euint8 lhs, euint8 rhs) internal returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n\n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the rem\n    function rem(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.rem(lhs, rhs);\n    }\n\n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the max\n    function max(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.max(lhs, rhs);\n    }\n\n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the min\n    function min(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.min(lhs, rhs);\n    }\n\n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the shl\n    function shl(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.shl(lhs, rhs);\n    }\n\n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the shr\n    function shr(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.shr(lhs, rhs);\n    }\n\n    /// @notice Performs the rol operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the rol\n    function rol(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.rol(lhs, rhs);\n    }\n\n    /// @notice Performs the ror operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @param rhs second input of type euint8\n    /// @return the result of the ror\n    function ror(euint8 lhs, euint8 rhs) internal returns (euint8) {\n        return FHE.ror(lhs, rhs);\n    }\n\n    /// @notice Performs the square operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the square\n    function square(euint8 lhs) internal returns (euint8) {\n        return FHE.square(lhs);\n    }\n    function toBool(euint8 value) internal  returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU16(euint8 value) internal returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(euint8 value) internal returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function toU64(euint8 value) internal returns (euint64) {\n        return FHE.asEuint64(value);\n    }\n    function toU128(euint8 value) internal returns (euint128) {\n        return FHE.asEuint128(value);\n    }\n    function toU256(euint8 value) internal returns (euint256) {\n        return FHE.asEuint256(value);\n    }\n    function decrypt(euint8 value) internal {\n        FHE.decrypt(value);\n    }\n    function allow(euint8 ctHash, address account) internal {\n        FHE.allow(ctHash, account);\n    }\n    function isAllowed(euint8 ctHash, address account) internal returns (bool) {\n        return FHE.isAllowed(ctHash, account);\n    }\n    function allowThis(euint8 ctHash) internal {\n        FHE.allowThis(ctHash);\n    }\n    function allowGlobal(euint8 ctHash) internal {\n        FHE.allowGlobal(ctHash);\n    }\n    function allowSender(euint8 ctHash) internal {\n        FHE.allowSender(ctHash);\n    }\n    function allowTransient(euint8 ctHash, address account) internal {\n        FHE.allowTransient(ctHash, account);\n    }\n}\n\nusing BindingsEuint16 for euint16 global;\nlibrary BindingsEuint16 {\n\n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the add\n    function add(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.add(lhs, rhs);\n    }\n\n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the mul\n    function mul(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.mul(lhs, rhs);\n    }\n\n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the div\n    function div(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.div(lhs, rhs);\n    }\n\n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the sub\n    function sub(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.sub(lhs, rhs);\n    }\n\n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the eq\n    function eq(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n\n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the ne\n    function ne(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n\n    /// @notice Performs the not operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the not\n    function not(euint16 lhs) internal returns (euint16) {\n        return FHE.not(lhs);\n    }\n\n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the and\n    function and(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.and(lhs, rhs);\n    }\n\n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the or\n    function or(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.or(lhs, rhs);\n    }\n\n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the xor\n    function xor(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.xor(lhs, rhs);\n    }\n\n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the gt\n    function gt(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n\n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the gte\n    function gte(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n\n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the lt\n    function lt(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n\n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the lte\n    function lte(euint16 lhs, euint16 rhs) internal returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n\n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the rem\n    function rem(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.rem(lhs, rhs);\n    }\n\n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the max\n    function max(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.max(lhs, rhs);\n    }\n\n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the min\n    function min(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.min(lhs, rhs);\n    }\n\n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the shl\n    function shl(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.shl(lhs, rhs);\n    }\n\n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the shr\n    function shr(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.shr(lhs, rhs);\n    }\n\n    /// @notice Performs the rol operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the rol\n    function rol(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.rol(lhs, rhs);\n    }\n\n    /// @notice Performs the ror operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @param rhs second input of type euint16\n    /// @return the result of the ror\n    function ror(euint16 lhs, euint16 rhs) internal returns (euint16) {\n        return FHE.ror(lhs, rhs);\n    }\n\n    /// @notice Performs the square operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the square\n    function square(euint16 lhs) internal returns (euint16) {\n        return FHE.square(lhs);\n    }\n    function toBool(euint16 value) internal  returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint16 value) internal returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU32(euint16 value) internal returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function toU64(euint16 value) internal returns (euint64) {\n        return FHE.asEuint64(value);\n    }\n    function toU128(euint16 value) internal returns (euint128) {\n        return FHE.asEuint128(value);\n    }\n    function toU256(euint16 value) internal returns (euint256) {\n        return FHE.asEuint256(value);\n    }\n    function decrypt(euint16 value) internal {\n        FHE.decrypt(value);\n    }\n    function allow(euint16 ctHash, address account) internal {\n        FHE.allow(ctHash, account);\n    }\n    function isAllowed(euint16 ctHash, address account) internal returns (bool) {\n        return FHE.isAllowed(ctHash, account);\n    }\n    function allowThis(euint16 ctHash) internal {\n        FHE.allowThis(ctHash);\n    }\n    function allowGlobal(euint16 ctHash) internal {\n        FHE.allowGlobal(ctHash);\n    }\n    function allowSender(euint16 ctHash) internal {\n        FHE.allowSender(ctHash);\n    }\n    function allowTransient(euint16 ctHash, address account) internal {\n        FHE.allowTransient(ctHash, account);\n    }\n}\n\nusing BindingsEuint32 for euint32 global;\nlibrary BindingsEuint32 {\n\n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the add\n    function add(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.add(lhs, rhs);\n    }\n\n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the mul\n    function mul(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.mul(lhs, rhs);\n    }\n\n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the div\n    function div(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.div(lhs, rhs);\n    }\n\n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the sub\n    function sub(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.sub(lhs, rhs);\n    }\n\n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the eq\n    function eq(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n\n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the ne\n    function ne(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n\n    /// @notice Performs the not operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the not\n    function not(euint32 lhs) internal returns (euint32) {\n        return FHE.not(lhs);\n    }\n\n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the and\n    function and(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.and(lhs, rhs);\n    }\n\n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the or\n    function or(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.or(lhs, rhs);\n    }\n\n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the xor\n    function xor(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.xor(lhs, rhs);\n    }\n\n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the gt\n    function gt(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n\n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the gte\n    function gte(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n\n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the lt\n    function lt(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n\n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the lte\n    function lte(euint32 lhs, euint32 rhs) internal returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n\n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the rem\n    function rem(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.rem(lhs, rhs);\n    }\n\n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the max\n    function max(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.max(lhs, rhs);\n    }\n\n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the min\n    function min(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.min(lhs, rhs);\n    }\n\n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the shl\n    function shl(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.shl(lhs, rhs);\n    }\n\n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the shr\n    function shr(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.shr(lhs, rhs);\n    }\n\n    /// @notice Performs the rol operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the rol\n    function rol(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.rol(lhs, rhs);\n    }\n\n    /// @notice Performs the ror operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @param rhs second input of type euint32\n    /// @return the result of the ror\n    function ror(euint32 lhs, euint32 rhs) internal returns (euint32) {\n        return FHE.ror(lhs, rhs);\n    }\n\n    /// @notice Performs the square operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the square\n    function square(euint32 lhs) internal returns (euint32) {\n        return FHE.square(lhs);\n    }\n    function toBool(euint32 value) internal  returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint32 value) internal returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(euint32 value) internal returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU64(euint32 value) internal returns (euint64) {\n        return FHE.asEuint64(value);\n    }\n    function toU128(euint32 value) internal returns (euint128) {\n        return FHE.asEuint128(value);\n    }\n    function toU256(euint32 value) internal returns (euint256) {\n        return FHE.asEuint256(value);\n    }\n    function decrypt(euint32 value) internal {\n        FHE.decrypt(value);\n    }\n    function allow(euint32 ctHash, address account) internal {\n        FHE.allow(ctHash, account);\n    }\n    function isAllowed(euint32 ctHash, address account) internal returns (bool) {\n        return FHE.isAllowed(ctHash, account);\n    }\n    function allowThis(euint32 ctHash) internal {\n        FHE.allowThis(ctHash);\n    }\n    function allowGlobal(euint32 ctHash) internal {\n        FHE.allowGlobal(ctHash);\n    }\n    function allowSender(euint32 ctHash) internal {\n        FHE.allowSender(ctHash);\n    }\n    function allowTransient(euint32 ctHash, address account) internal {\n        FHE.allowTransient(ctHash, account);\n    }\n}\n\nusing BindingsEuint64 for euint64 global;\nlibrary BindingsEuint64 {\n\n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the add\n    function add(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.add(lhs, rhs);\n    }\n\n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the mul\n    function mul(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.mul(lhs, rhs);\n    }\n\n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the sub\n    function sub(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.sub(lhs, rhs);\n    }\n\n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the eq\n    function eq(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n\n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the ne\n    function ne(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n\n    /// @notice Performs the not operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @return the result of the not\n    function not(euint64 lhs) internal returns (euint64) {\n        return FHE.not(lhs);\n    }\n\n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the and\n    function and(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.and(lhs, rhs);\n    }\n\n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the or\n    function or(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.or(lhs, rhs);\n    }\n\n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the xor\n    function xor(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.xor(lhs, rhs);\n    }\n\n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the gt\n    function gt(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n\n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the gte\n    function gte(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n\n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the lt\n    function lt(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n\n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the lte\n    function lte(euint64 lhs, euint64 rhs) internal returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n\n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the max\n    function max(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.max(lhs, rhs);\n    }\n\n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the min\n    function min(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.min(lhs, rhs);\n    }\n\n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the shl\n    function shl(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.shl(lhs, rhs);\n    }\n\n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the shr\n    function shr(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.shr(lhs, rhs);\n    }\n\n    /// @notice Performs the rol operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the rol\n    function rol(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.rol(lhs, rhs);\n    }\n\n    /// @notice Performs the ror operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @param rhs second input of type euint64\n    /// @return the result of the ror\n    function ror(euint64 lhs, euint64 rhs) internal returns (euint64) {\n        return FHE.ror(lhs, rhs);\n    }\n\n    /// @notice Performs the square operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint64\n    /// @return the result of the square\n    function square(euint64 lhs) internal returns (euint64) {\n        return FHE.square(lhs);\n    }\n    function toBool(euint64 value) internal  returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint64 value) internal returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(euint64 value) internal returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(euint64 value) internal returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function toU128(euint64 value) internal returns (euint128) {\n        return FHE.asEuint128(value);\n    }\n    function toU256(euint64 value) internal returns (euint256) {\n        return FHE.asEuint256(value);\n    }\n    function decrypt(euint64 value) internal {\n        FHE.decrypt(value);\n    }\n    function allow(euint64 ctHash, address account) internal {\n        FHE.allow(ctHash, account);\n    }\n    function isAllowed(euint64 ctHash, address account) internal returns (bool) {\n        return FHE.isAllowed(ctHash, account);\n    }\n    function allowThis(euint64 ctHash) internal {\n        FHE.allowThis(ctHash);\n    }\n    function allowGlobal(euint64 ctHash) internal {\n        FHE.allowGlobal(ctHash);\n    }\n    function allowSender(euint64 ctHash) internal {\n        FHE.allowSender(ctHash);\n    }\n    function allowTransient(euint64 ctHash, address account) internal {\n        FHE.allowTransient(ctHash, account);\n    }\n}\n\nusing BindingsEuint128 for euint128 global;\nlibrary BindingsEuint128 {\n\n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the add\n    function add(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.add(lhs, rhs);\n    }\n\n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the sub\n    function sub(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.sub(lhs, rhs);\n    }\n\n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the eq\n    function eq(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n\n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the ne\n    function ne(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n\n    /// @notice Performs the not operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @return the result of the not\n    function not(euint128 lhs) internal returns (euint128) {\n        return FHE.not(lhs);\n    }\n\n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the and\n    function and(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.and(lhs, rhs);\n    }\n\n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the or\n    function or(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.or(lhs, rhs);\n    }\n\n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the xor\n    function xor(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.xor(lhs, rhs);\n    }\n\n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the gt\n    function gt(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n\n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the gte\n    function gte(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n\n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the lt\n    function lt(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n\n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the lte\n    function lte(euint128 lhs, euint128 rhs) internal returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n\n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the max\n    function max(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.max(lhs, rhs);\n    }\n\n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the min\n    function min(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.min(lhs, rhs);\n    }\n\n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the shl\n    function shl(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.shl(lhs, rhs);\n    }\n\n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the shr\n    function shr(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.shr(lhs, rhs);\n    }\n\n    /// @notice Performs the rol operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the rol\n    function rol(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.rol(lhs, rhs);\n    }\n\n    /// @notice Performs the ror operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint128\n    /// @param rhs second input of type euint128\n    /// @return the result of the ror\n    function ror(euint128 lhs, euint128 rhs) internal returns (euint128) {\n        return FHE.ror(lhs, rhs);\n    }\n    function toBool(euint128 value) internal  returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint128 value) internal returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(euint128 value) internal returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(euint128 value) internal returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function toU64(euint128 value) internal returns (euint64) {\n        return FHE.asEuint64(value);\n    }\n    function toU256(euint128 value) internal returns (euint256) {\n        return FHE.asEuint256(value);\n    }\n    function decrypt(euint128 value) internal {\n        FHE.decrypt(value);\n    }\n    function allow(euint128 ctHash, address account) internal {\n        FHE.allow(ctHash, account);\n    }\n    function isAllowed(euint128 ctHash, address account) internal returns (bool) {\n        return FHE.isAllowed(ctHash, account);\n    }\n    function allowThis(euint128 ctHash) internal {\n        FHE.allowThis(ctHash);\n    }\n    function allowGlobal(euint128 ctHash) internal {\n        FHE.allowGlobal(ctHash);\n    }\n    function allowSender(euint128 ctHash) internal {\n        FHE.allowSender(ctHash);\n    }\n    function allowTransient(euint128 ctHash, address account) internal {\n        FHE.allowTransient(ctHash, account);\n    }\n}\n\nusing BindingsEuint256 for euint256 global;\nlibrary BindingsEuint256 {\n\n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return the result of the eq\n    function eq(euint256 lhs, euint256 rhs) internal returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n\n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint256\n    /// @param rhs second input of type euint256\n    /// @return the result of the ne\n    function ne(euint256 lhs, euint256 rhs) internal returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    function toBool(euint256 value) internal  returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint256 value) internal returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(euint256 value) internal returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(euint256 value) internal returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function toU64(euint256 value) internal returns (euint64) {\n        return FHE.asEuint64(value);\n    }\n    function toU128(euint256 value) internal returns (euint128) {\n        return FHE.asEuint128(value);\n    }\n    function toEaddress(euint256 value) internal returns (eaddress) {\n        return FHE.asEaddress(value);\n    }\n    function decrypt(euint256 value) internal {\n        FHE.decrypt(value);\n    }\n    function allow(euint256 ctHash, address account) internal {\n        FHE.allow(ctHash, account);\n    }\n    function isAllowed(euint256 ctHash, address account) internal returns (bool) {\n        return FHE.isAllowed(ctHash, account);\n    }\n    function allowThis(euint256 ctHash) internal {\n        FHE.allowThis(ctHash);\n    }\n    function allowGlobal(euint256 ctHash) internal {\n        FHE.allowGlobal(ctHash);\n    }\n    function allowSender(euint256 ctHash) internal {\n        FHE.allowSender(ctHash);\n    }\n    function allowTransient(euint256 ctHash, address account) internal {\n        FHE.allowTransient(ctHash, account);\n    }\n}\n\nusing BindingsEaddress for eaddress global;\nlibrary BindingsEaddress {\n\n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type eaddress\n    /// @param rhs second input of type eaddress\n    /// @return the result of the eq\n    function eq(eaddress lhs, eaddress rhs) internal returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n\n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type eaddress\n    /// @param rhs second input of type eaddress\n    /// @return the result of the ne\n    function ne(eaddress lhs, eaddress rhs) internal returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    function toBool(eaddress value) internal  returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(eaddress value) internal returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(eaddress value) internal returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(eaddress value) internal returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function toU64(eaddress value) internal returns (euint64) {\n        return FHE.asEuint64(value);\n    }\n    function toU128(eaddress value) internal returns (euint128) {\n        return FHE.asEuint128(value);\n    }\n    function toU256(eaddress value) internal returns (euint256) {\n        return FHE.asEuint256(value);\n    }\n    function decrypt(eaddress value) internal {\n        FHE.decrypt(value);\n    }\n    function allow(eaddress ctHash, address account) internal {\n        FHE.allow(ctHash, account);\n    }\n    function isAllowed(eaddress ctHash, address account) internal returns (bool) {\n        return FHE.isAllowed(ctHash, account);\n    }\n    function allowThis(eaddress ctHash) internal {\n        FHE.allowThis(ctHash);\n    }\n    function allowGlobal(eaddress ctHash) internal {\n        FHE.allowGlobal(ctHash);\n    }\n    function allowSender(eaddress ctHash) internal {\n        FHE.allowSender(ctHash);\n    }\n    function allowTransient(eaddress ctHash, address account) internal {\n        FHE.allowTransient(ctHash, account);\n    }\n}\n"
    },
    "@luxfheprotocol/cofhe-contracts/ICofhe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.25 <0.9.0;\n\nstruct EncryptedInput {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\n\nstruct InEbool {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\n\nstruct InEuint8 {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\n\nstruct InEuint16 {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\n\nstruct InEuint32 {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\n\nstruct InEuint64 {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\n\nstruct InEuint128 {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\n\nstruct InEuint256 {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\nstruct InEaddress {\n    uint256 ctHash;\n    uint8 securityZone;\n    uint8 utype;\n    bytes signature;\n}\n\n\n// Order is set as in fheos/precompiles/types/types.go\nenum FunctionId {\n    _0,             // 0 - GetNetworkKey\n    _1,             // 1 - Verify\n    cast,           // 2\n    sealoutput,     // 3\n    select,         // 4 - select\n    _5,             // 5 - req\n    decrypt,        // 6\n    sub,            // 7\n    add,            // 8\n    xor,            // 9\n    and,            // 10\n    or,             // 11\n    not,            // 12\n    div,            // 13\n    rem,            // 14\n    mul,            // 15\n    shl,            // 16\n    shr,            // 17\n    gte,            // 18\n    lte,            // 19\n    lt,             // 20\n    gt,             // 21\n    min,            // 22\n    max,            // 23\n    eq,             // 24\n    ne,             // 25\n    trivialEncrypt, // 26\n    random,         // 27\n    rol,            // 28\n    ror,            // 29\n    square,         // 30\n    _31             // 31\n}\n\ninterface ITaskManager {\n    function createTask(uint8 returnType, FunctionId funcId, uint256[] memory encryptedInputs, uint256[] memory extraInputs) external returns (uint256);\n\n    function createDecryptTask(uint256 ctHash, address requestor) external;\n    function verifyInput(EncryptedInput memory input, address sender) external returns (uint256);\n\n    function allow(uint256 ctHash, address account) external;\n    function isAllowed(uint256 ctHash, address account) external returns (bool);\n    function allowGlobal(uint256 ctHash) external;\n    function allowTransient(uint256 ctHash, address account) external;\n    function getDecryptResultSafe(uint256 ctHash) external view returns (uint256, bool);\n    function getDecryptResult(uint256 ctHash) external view returns (uint256);\n}\n\nlibrary Utils {\n    // Values used to communicate types to the runtime.\n    // Must match values defined in warp-drive protobufs for everything to\n    uint8 internal constant EUINT8_TFHE = 2;\n    uint8 internal constant EUINT16_TFHE = 3;\n    uint8 internal constant EUINT32_TFHE = 4;\n    uint8 internal constant EUINT64_TFHE = 5;\n    uint8 internal constant EUINT128_TFHE = 6;\n    uint8 internal constant EUINT256_TFHE = 8;\n    uint8 internal constant EADDRESS_TFHE = 7;\n    uint8 internal constant EBOOL_TFHE = 0;\n\n    function functionIdToString(FunctionId _functionId) internal pure returns (string memory) {\n        if (_functionId == FunctionId.cast) return \"cast\";\n        if (_functionId == FunctionId.sealoutput) return \"sealOutput\";\n        if (_functionId == FunctionId.select) return \"select\";\n        if (_functionId == FunctionId.decrypt) return \"decrypt\";\n        if (_functionId == FunctionId.sub) return \"sub\";\n        if (_functionId == FunctionId.add) return \"add\";\n        if (_functionId == FunctionId.xor) return \"xor\";\n        if (_functionId == FunctionId.and) return \"and\";\n        if (_functionId == FunctionId.or) return \"or\";\n        if (_functionId == FunctionId.not) return \"not\";\n        if (_functionId == FunctionId.div) return \"div\";\n        if (_functionId == FunctionId.rem) return \"rem\";\n        if (_functionId == FunctionId.mul) return \"mul\";\n        if (_functionId == FunctionId.shl) return \"shl\";\n        if (_functionId == FunctionId.shr) return \"shr\";\n        if (_functionId == FunctionId.gte) return \"gte\";\n        if (_functionId == FunctionId.lte) return \"lte\";\n        if (_functionId == FunctionId.lt) return \"lt\";\n        if (_functionId == FunctionId.gt) return \"gt\";\n        if (_functionId == FunctionId.min) return \"min\";\n        if (_functionId == FunctionId.max) return \"max\";\n        if (_functionId == FunctionId.eq) return \"eq\";\n        if (_functionId == FunctionId.ne) return \"ne\";\n        if (_functionId == FunctionId.trivialEncrypt) return \"trivialEncrypt\";\n        if (_functionId == FunctionId.random) return \"random\";\n        if (_functionId == FunctionId.rol) return \"rol\";\n        if (_functionId == FunctionId.ror) return \"ror\";\n        if (_functionId == FunctionId.square) return \"square\";\n\n        return \"\";\n    }\n\n    function inputFromEbool(InEbool memory input) internal pure returns (EncryptedInput memory) {\n        return EncryptedInput({\n            ctHash: input.ctHash,\n            securityZone: input.securityZone,\n            utype: EBOOL_TFHE,\n            signature: input.signature\n        });\n    }\n\n    function inputFromEuint8(InEuint8 memory input) internal pure returns (EncryptedInput memory) {\n        return EncryptedInput({\n            ctHash: input.ctHash,\n            securityZone: input.securityZone,\n            utype: EUINT8_TFHE,\n            signature: input.signature\n        });\n    }\n\n    function inputFromEuint16(InEuint16 memory input) internal pure returns (EncryptedInput memory) {\n        return EncryptedInput({\n            ctHash: input.ctHash,\n            securityZone: input.securityZone,\n            utype: EUINT16_TFHE,\n            signature: input.signature\n        });\n    }\n\n    function inputFromEuint32(InEuint32 memory input) internal pure returns (EncryptedInput memory) {\n        return EncryptedInput({\n            ctHash: input.ctHash,\n            securityZone: input.securityZone,\n            utype: EUINT32_TFHE,\n            signature: input.signature\n        });\n    }\n\n    function inputFromEuint64(InEuint64 memory input) internal pure returns (EncryptedInput memory) {\n        return EncryptedInput({\n            ctHash: input.ctHash,\n            securityZone: input.securityZone,\n            utype: EUINT64_TFHE,\n            signature: input.signature\n        });\n    }\n\n    function inputFromEuint128(InEuint128 memory input) internal pure returns (EncryptedInput memory) {\n        return EncryptedInput({\n            ctHash: input.ctHash,\n            securityZone: input.securityZone,\n            utype: EUINT128_TFHE,\n            signature: input.signature\n        });\n    }\n\n    function inputFromEuint256(InEuint256 memory input) internal pure returns (EncryptedInput memory) {\n        return EncryptedInput({\n            ctHash: input.ctHash,\n            securityZone: input.securityZone,\n            utype: EUINT256_TFHE,\n            signature: input.signature\n        });\n    }\n\n    function inputFromEaddress(InEaddress memory input) internal pure returns (EncryptedInput memory) {\n        return EncryptedInput({\n            ctHash: input.ctHash,\n            securityZone: input.securityZone,\n            utype: EADDRESS_TFHE,\n            signature: input.signature\n        });\n    }\n}"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
    },
    "contracts/SecretSantaFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {FHE, euint32, ebool, InEuint32} from \"@luxfheprotocol/cofhe-contracts/FHE.sol\";\n\n/// \n/// SECRET SANTA - Password Protected Games with FHE\n/// \n///\n/// All games are stored in mappings within this single contract.\n/// Games can optionally be password protected using FHE encryption.\n///\n/// \n/// FLOW\n/// \n///\n/// CREATE GAME:\n///   1. Creator encrypts entropy (and optionally password) client-side\n///   2. createGame(name, entropy, password, hasPassword)  new game ID\n///   3. Creator auto-registered, share game ID (and password) with friends\n///\n/// JOIN GAME (2-step for password games):\n///   1. Player encrypts entropy and password client-side\n///   2. requestJoinGame(gameId, password, entropy)\n///      - Public games: immediately joined\n///      - Password games: starts async password verification\n///   3. completeJoinGame(gameId) - only for password games after decryption ready\n///\n/// FINALIZE:\n///   1. Creator calls finalizeGame() when ready (3+ players)\n///   2. LCG permutation creates encrypted assignments\n///   3. Each player can only decrypt their own target\n///\n/// \n\ncontract SecretSanta {\n    // \n    // TYPES\n    // \n\n    enum GameState {\n        REGISTRATION,\n        ACTIVE,\n        REVEALED\n    }\n\n    struct Game {\n        uint256 gameId;\n        address creator;\n        string name;\n        uint256 createdAt;\n        GameState state;\n        address[] participants;\n        euint32 entropy;\n        euint32 password;      // Encrypted password (only used if hasPassword)\n        bool hasPassword;      // Flag for password protection\n    }\n\n    struct GameInfo {\n        uint256 gameId;\n        address creator;\n        string name;\n        uint256 createdAt;\n        uint8 state;\n        uint256 playerCount;\n        bool hasPassword;      // Indicates if game requires password\n    }\n\n    struct PendingJoin {\n        ebool passwordMatch;   // Encrypted comparison result\n        euint32 userEntropy;   // Store entropy for later use\n        bool exists;\n    }\n\n    // \n    // STATE\n    // \n\n    uint256 public gameCount;\n\n    // Game data\n    mapping(uint256 => Game) internal games;\n\n    // Player registration per game: gameId => player => participantIndex (1-indexed, 0 = not registered)\n    mapping(uint256 => mapping(address => uint256)) public playerIndex;\n\n    // Encrypted destinations per game: gameId => participantIndex => encrypted target index\n    mapping(uint256 => mapping(uint256 => euint32)) internal destinations;\n\n    // Track games by creator and player\n    mapping(address => uint256[]) public gamesByCreator;\n    mapping(address => uint256[]) public gamesByPlayer;\n\n    // Pending join requests for password-protected games\n    mapping(uint256 => mapping(address => PendingJoin)) internal pendingJoins;\n\n    // \n    // EVENTS\n    // \n\n    event GameCreated(\n        uint256 indexed gameId,\n        address indexed creator,\n        string name,\n        bool hasPassword\n    );\n\n    event PlayerJoined(uint256 indexed gameId, address indexed player);\n    event JoinRequested(uint256 indexed gameId, address indexed player);\n    event GameFinalized(uint256 indexed gameId);\n    event GameRevealed(uint256 indexed gameId);\n\n    // \n    // ERRORS\n    // \n\n    error GameNotFound();\n    error NotRegistrationPhase();\n    error AlreadyRegistered();\n    error PendingJoinExists();\n    error NoPendingJoin();\n    error DecryptionNotReady();\n    error InvalidPassword();\n    error NotCreator();\n    error NotActive();\n    error NeedAtLeast3Players();\n    error NotRegistered();\n    error GameNotStarted();\n\n    // \n    // CREATE GAME\n    // \n\n    /// @notice Create a new Secret Santa game\n    /// @param name The name of the game\n    /// @param creatorEntropy Encrypted random value for assignment randomness\n    /// @param password Encrypted password (ignored if hasPassword is false)\n    /// @param hasPassword Whether the game requires a password to join\n    /// @return gameId The ID of the created game\n    function createGame(\n        string calldata name,\n        InEuint32 calldata creatorEntropy,\n        InEuint32 calldata password,\n        bool hasPassword\n    ) external returns (uint256 gameId) {\n        gameId = gameCount++;\n\n        Game storage game = games[gameId];\n        game.gameId = gameId;\n        game.creator = msg.sender;\n        game.name = name;\n        game.createdAt = block.timestamp;\n        game.state = GameState.REGISTRATION;\n        game.entropy = FHE.asEuint32(creatorEntropy);\n        game.hasPassword = hasPassword;\n\n        FHE.allowThis(game.entropy);\n\n        if (hasPassword) {\n            game.password = FHE.asEuint32(password);\n            FHE.allowThis(game.password);\n        }\n\n        // Auto-register creator (no password check needed)\n        game.participants.push(msg.sender);\n        playerIndex[gameId][msg.sender] = 1; // 1-indexed\n\n        gamesByCreator[msg.sender].push(gameId);\n        gamesByPlayer[msg.sender].push(gameId);\n\n        emit GameCreated(gameId, msg.sender, name, hasPassword);\n    }\n\n    // \n    // JOIN GAME (2-step for password games)\n    // \n\n    /// @notice Request to join a game (Step 1)\n    /// @dev For public games, joins immediately. For password games, starts async verification.\n    /// @param gameId The ID of the game to join\n    /// @param password Encrypted password guess (ignored for public games)\n    /// @param userEntropy Encrypted random value for assignment randomness\n    function requestJoinGame(\n        uint256 gameId,\n        InEuint32 calldata password,\n        InEuint32 calldata userEntropy\n    ) external {\n        if (gameId >= gameCount) revert GameNotFound();\n        Game storage game = games[gameId];\n\n        if (game.state != GameState.REGISTRATION) revert NotRegistrationPhase();\n        if (playerIndex[gameId][msg.sender] != 0) revert AlreadyRegistered();\n        if (pendingJoins[gameId][msg.sender].exists) revert PendingJoinExists();\n\n        if (!game.hasPassword) {\n            // No password - directly join\n            _addPlayer(gameId, userEntropy);\n            return;\n        }\n\n        // Password protected - start async verification\n        euint32 submittedPwd = FHE.asEuint32(password);\n        ebool passwordMatch = FHE.eq(game.password, submittedPwd);\n\n        // Store entropy as euint32 for later use\n        euint32 storedEntropy = FHE.asEuint32(userEntropy);\n        FHE.allowThis(storedEntropy);\n\n        // Request decryption of the match result\n        FHE.decrypt(passwordMatch);\n\n        // Store pending join\n        pendingJoins[gameId][msg.sender] = PendingJoin({\n            passwordMatch: passwordMatch,\n            userEntropy: storedEntropy,\n            exists: true\n        });\n\n        emit JoinRequested(gameId, msg.sender);\n    }\n\n    /// @notice Complete joining a password-protected game (Step 2)\n    /// @dev Called after password verification decryption is ready\n    /// @param gameId The ID of the game to join\n    function completeJoinGame(uint256 gameId) external {\n        if (gameId >= gameCount) revert GameNotFound();\n        Game storage game = games[gameId];\n\n        if (game.state != GameState.REGISTRATION) revert NotRegistrationPhase();\n        if (!pendingJoins[gameId][msg.sender].exists) revert NoPendingJoin();\n\n        PendingJoin storage pending = pendingJoins[gameId][msg.sender];\n\n        // Get decrypted result\n        (bool matched, bool decrypted) = FHE.getDecryptResultSafe(pending.passwordMatch);\n        if (!decrypted) revert DecryptionNotReady();\n        if (!matched) {\n            // Clean up failed attempt so user can retry\n            delete pendingJoins[gameId][msg.sender];\n            revert InvalidPassword();\n        }\n\n        // Password matched - add player using stored entropy\n        _addPlayerWithStoredEntropy(gameId, pending.userEntropy);\n\n        // Clean up pending join\n        delete pendingJoins[gameId][msg.sender];\n    }\n\n    /// @notice Internal function to add a player with fresh entropy input\n    function _addPlayer(uint256 gameId, InEuint32 calldata userEntropy) internal {\n        Game storage game = games[gameId];\n\n        game.participants.push(msg.sender);\n        playerIndex[gameId][msg.sender] = game.participants.length; // 1-indexed\n\n        // XOR entropy for combined randomness\n        game.entropy = FHE.xor(game.entropy, FHE.asEuint32(userEntropy));\n        FHE.allowThis(game.entropy);\n\n        gamesByPlayer[msg.sender].push(gameId);\n\n        emit PlayerJoined(gameId, msg.sender);\n    }\n\n    /// @notice Internal function to add a player with already-stored entropy\n    function _addPlayerWithStoredEntropy(uint256 gameId, euint32 userEntropy) internal {\n        Game storage game = games[gameId];\n\n        game.participants.push(msg.sender);\n        playerIndex[gameId][msg.sender] = game.participants.length; // 1-indexed\n\n        // XOR entropy for combined randomness\n        game.entropy = FHE.xor(game.entropy, userEntropy);\n        FHE.allowThis(game.entropy);\n\n        gamesByPlayer[msg.sender].push(gameId);\n\n        emit PlayerJoined(gameId, msg.sender);\n    }\n\n    // \n    // VIEW: JOIN STATUS\n    // \n\n    /// @notice Check the join status for a player\n    /// @param gameId The game ID\n    /// @param player The player address\n    /// @return hasPending Whether there's a pending join request\n    /// @return isDecrypted Whether the password verification is complete\n    /// @return isRegistered Whether the player is already registered\n    function getJoinStatus(\n        uint256 gameId,\n        address player\n    ) external view returns (bool hasPending, bool isDecrypted, bool isRegistered) {\n        hasPending = pendingJoins[gameId][player].exists;\n        isRegistered = playerIndex[gameId][player] != 0;\n\n        if (hasPending) {\n            (, isDecrypted) = FHE.getDecryptResultSafe(pendingJoins[gameId][player].passwordMatch);\n        }\n    }\n\n    // \n    // FINALIZE GAME (LCG Permutation)\n    // \n\n    /// @notice Finalize a game and generate encrypted assignments (creator only)\n    /// @param gameId The ID of the game to finalize\n    function finalizeGame(uint256 gameId) external {\n        if (gameId >= gameCount) revert GameNotFound();\n        Game storage game = games[gameId];\n\n        if (msg.sender != game.creator) revert NotCreator();\n        if (game.state != GameState.REGISTRATION) revert NotRegistrationPhase();\n        if (game.participants.length < 3) revert NeedAtLeast3Players();\n\n        uint256 n = game.participants.length;\n        euint32 nEnc = FHE.asEuint32(uint32(n));\n\n        // Random shift: dest[i] = (i + shift) mod n, shift  [1, n-1]\n        // Guarantees no self-assignments (since shift != 0)\n        euint32 shift = FHE.add(\n            FHE.rem(game.entropy, FHE.asEuint32(uint32(n - 1))),\n            FHE.asEuint32(1)\n        );\n\n        for (uint256 i = 0; i < n; i++) {\n            euint32 dest = FHE.rem(\n                FHE.add(shift, FHE.asEuint32(uint32(i))),\n                nEnc\n            );\n            destinations[gameId][i] = dest;\n            FHE.allow(dest, game.participants[i]);\n            FHE.allowThis(dest);\n        }\n\n        game.state = GameState.ACTIVE;\n\n        emit GameFinalized(gameId);\n    }\n\n    // \n    // REVEAL (Optional - makes all assignments public)\n    // \n\n    /// @notice Reveal all assignments to everyone (creator only)\n    /// @param gameId The ID of the game to reveal\n    function revealGame(uint256 gameId) external {\n        if (gameId >= gameCount) revert GameNotFound();\n        Game storage game = games[gameId];\n\n        if (msg.sender != game.creator) revert NotCreator();\n        if (game.state != GameState.ACTIVE) revert NotActive();\n\n        uint256 n = game.participants.length;\n\n        // Allow everyone to see all destinations\n        for (uint256 i = 0; i < n; i++) {\n            for (uint256 j = 0; j < n; j++) {\n                FHE.allow(destinations[gameId][i], game.participants[j]);\n            }\n        }\n\n        game.state = GameState.REVEALED;\n\n        emit GameRevealed(gameId);\n    }\n\n    // \n    // VIEW FUNCTIONS\n    // \n\n    /// @notice Get your encrypted target index (decrypt client-side with permit)\n    function getMyTarget(uint256 gameId) external view returns (euint32) {\n        if (gameId >= gameCount) revert GameNotFound();\n        Game storage game = games[gameId];\n\n        if (game.state == GameState.REGISTRATION) revert GameNotStarted();\n\n        uint256 idx = playerIndex[gameId][msg.sender];\n        if (idx == 0) revert NotRegistered();\n\n        return destinations[gameId][idx - 1]; // Convert from 1-indexed\n    }\n\n    /// @notice Get game info\n    function getGame(uint256 gameId) external view returns (GameInfo memory) {\n        if (gameId >= gameCount) revert GameNotFound();\n        Game storage game = games[gameId];\n\n        return GameInfo({\n            gameId: game.gameId,\n            creator: game.creator,\n            name: game.name,\n            createdAt: game.createdAt,\n            state: uint8(game.state),\n            playerCount: game.participants.length,\n            hasPassword: game.hasPassword\n        });\n    }\n\n    /// @notice Get all participants in a game\n    function getParticipants(uint256 gameId) external view returns (address[] memory) {\n        if (gameId >= gameCount) revert GameNotFound();\n        return games[gameId].participants;\n    }\n\n    /// @notice Get a specific participant by index\n    function getParticipant(uint256 gameId, uint256 idx) external view returns (address) {\n        if (gameId >= gameCount) revert GameNotFound();\n        require(idx < games[gameId].participants.length, \"invalid index\");\n        return games[gameId].participants[idx];\n    }\n\n    /// @notice Get participant count for a game\n    function getParticipantCount(uint256 gameId) external view returns (uint256) {\n        if (gameId >= gameCount) revert GameNotFound();\n        return games[gameId].participants.length;\n    }\n\n    /// @notice Check if a user is registered in a game\n    function isRegistered(uint256 gameId, address user) external view returns (bool) {\n        return playerIndex[gameId][user] != 0;\n    }\n\n    /// @notice Get games created by an address\n    function getGamesByCreator(address creator) external view returns (uint256[] memory) {\n        return gamesByCreator[creator];\n    }\n\n    /// @notice Get games a player is participating in\n    function getGamesByPlayer(address player) external view returns (uint256[] memory) {\n        return gamesByPlayer[player];\n    }\n\n    /// @notice List games with pagination\n    function listGames(\n        uint256 offset,\n        uint256 limit\n    ) external view returns (GameInfo[] memory) {\n        if (offset >= gameCount) return new GameInfo[](0);\n\n        uint256 count = gameCount - offset;\n        if (count > limit) count = limit;\n\n        GameInfo[] memory result = new GameInfo[](count);\n        for (uint256 i = 0; i < count; i++) {\n            Game storage game = games[offset + i];\n            result[i] = GameInfo({\n                gameId: game.gameId,\n                creator: game.creator,\n                name: game.name,\n                createdAt: game.createdAt,\n                state: uint8(game.state),\n                playerCount: game.participants.length,\n                hasPassword: game.hasPassword\n            });\n        }\n        return result;\n    }\n\n    /// @notice List only open games (registration phase)\n    function listOpenGames(\n        uint256 offset,\n        uint256 limit\n    ) external view returns (GameInfo[] memory) {\n        // Count open games first\n        uint256 openCount = 0;\n        for (uint256 i = 0; i < gameCount; i++) {\n            if (games[i].state == GameState.REGISTRATION) openCount++;\n        }\n\n        if (openCount == 0 || offset >= openCount) return new GameInfo[](0);\n\n        uint256 count = openCount - offset;\n        if (count > limit) count = limit;\n\n        GameInfo[] memory result = new GameInfo[](count);\n        uint256 found = 0;\n        uint256 skipped = 0;\n\n        for (uint256 i = 0; i < gameCount && found < count; i++) {\n            if (games[i].state == GameState.REGISTRATION) {\n                if (skipped >= offset) {\n                    Game storage game = games[i];\n                    result[found] = GameInfo({\n                        gameId: game.gameId,\n                        creator: game.creator,\n                        name: game.name,\n                        createdAt: game.createdAt,\n                        state: uint8(game.state),\n                        playerCount: game.participants.length,\n                        hasPassword: game.hasPassword\n                    });\n                    found++;\n                } else {\n                    skipped++;\n                }\n            }\n        }\n        return result;\n    }\n\n    /// @notice Get destination for a player index (only after reveal)\n    function getDestination(uint256 gameId, uint256 idx) external view returns (euint32) {\n        if (gameId >= gameCount) revert GameNotFound();\n        require(games[gameId].state == GameState.REVEALED, \"not revealed\");\n        return destinations[gameId][idx];\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}